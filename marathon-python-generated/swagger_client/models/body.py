# coding: utf-8

"""
Copyright 2015 SmartBear Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    Ref: https://github.com/swagger-api/swagger-codegen
"""

from pprint import pformat
from six import iteritems


class Body(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    """
    def __init__(self):
        """
        Body - a model defined in Swagger

        :param dict swaggerTypes: The key is attribute name
                                  and the value is attribute type.
        :param dict attributeMap: The key is attribute name
                                  and the value is json key in definition.
        """
        self.swagger_types = {
            'accepted_resource_roles': 'list[str]',
            'args': 'list[str]',
            'backoff_factor': 'float',
            'backoff_seconds': 'int',
            'cmd': 'str',
            'constraints': 'list[list[ERRORUNKNOWN]]',
            'container': 'V2appsContainer',
            'cpus': 'float',
            'dependencies': 'list[PathType]',
            'disk': 'float',
            'env': 'object',
            'executor': 'str',
            'fetch': 'list[V2appsFetch]',
            'health_checks': 'list[V2appsHealthChecks]',
            'id': 'PathType',
            'instances': 'int',
            'labels': 'dict(str, str)',
            'max_launch_delay_seconds': 'int',
            'mem': 'float',
            'ip_address': 'V2appsIpAddress',
            'ports': 'list[int]',
            'residency': 'V2appsResidency',
            'require_ports': 'bool',
            'store_urls': 'list[str]',
            'upgrade_strategy': 'V2appsUpgradeStrategy',
            'uris': 'list[str]',
            'user': 'str',
            'version': 'datetime',
            'version_info': 'V2appsVersionInfo'
        }

        self.attribute_map = {
            'accepted_resource_roles': 'acceptedResourceRoles',
            'args': 'args',
            'backoff_factor': 'backoffFactor',
            'backoff_seconds': 'backoffSeconds',
            'cmd': 'cmd',
            'constraints': 'constraints',
            'container': 'container',
            'cpus': 'cpus',
            'dependencies': 'dependencies',
            'disk': 'disk',
            'env': 'env',
            'executor': 'executor',
            'fetch': 'fetch',
            'health_checks': 'healthChecks',
            'id': 'id',
            'instances': 'instances',
            'labels': 'labels',
            'max_launch_delay_seconds': 'maxLaunchDelaySeconds',
            'mem': 'mem',
            'ip_address': 'ipAddress',
            'ports': 'ports',
            'residency': 'residency',
            'require_ports': 'requirePorts',
            'store_urls': 'storeUrls',
            'upgrade_strategy': 'upgradeStrategy',
            'uris': 'uris',
            'user': 'user',
            'version': 'version',
            'version_info': 'versionInfo'
        }

        self._accepted_resource_roles = None
        self._args = None
        self._backoff_factor = None
        self._backoff_seconds = None
        self._cmd = None
        self._constraints = None
        self._container = None
        self._cpus = None
        self._dependencies = None
        self._disk = None
        self._env = None
        self._executor = None
        self._fetch = None
        self._health_checks = None
        self._id = None
        self._instances = None
        self._labels = None
        self._max_launch_delay_seconds = None
        self._mem = None
        self._ip_address = None
        self._ports = None
        self._residency = None
        self._require_ports = None
        self._store_urls = None
        self._upgrade_strategy = None
        self._uris = None
        self._user = None
        self._version = None
        self._version_info = None

    @property
    def accepted_resource_roles(self):
        """
        Gets the accepted_resource_roles of this Body.
        Optional. A list of resource roles. Marathon considers only resource offers with roles in this list for launching tasks of this app. If you do not specify this, Marathon considers all resource offers with roles that have been configured by the `--default_accepted_resource_roles` command line flag. If no `--default_accepted_resource_roles` was given on startup, Marathon considers all resource offers. To register Marathon for a role, you need to specify the `--mesos_role` command line flag on startup. If you want to assign all resources of a slave to a role, you can use the `--default_role` argument when starting up the slave. If you need a more fine-grained configuration, you can use the `--resources` argument to specify resource shares per role. The Mesos master needs to be started with `--roles` followed by a comma-separated list of all roles you want to use across your cluster. See [the Mesos command line documentation](http://mesos.apache.org/documentation/latest/configuration/) for details.

        :return: The accepted_resource_roles of this Body.
        :rtype: list[str]
        """
        return self._accepted_resource_roles

    @accepted_resource_roles.setter
    def accepted_resource_roles(self, accepted_resource_roles):
        """
        Sets the accepted_resource_roles of this Body.
        Optional. A list of resource roles. Marathon considers only resource offers with roles in this list for launching tasks of this app. If you do not specify this, Marathon considers all resource offers with roles that have been configured by the `--default_accepted_resource_roles` command line flag. If no `--default_accepted_resource_roles` was given on startup, Marathon considers all resource offers. To register Marathon for a role, you need to specify the `--mesos_role` command line flag on startup. If you want to assign all resources of a slave to a role, you can use the `--default_role` argument when starting up the slave. If you need a more fine-grained configuration, you can use the `--resources` argument to specify resource shares per role. The Mesos master needs to be started with `--roles` followed by a comma-separated list of all roles you want to use across your cluster. See [the Mesos command line documentation](http://mesos.apache.org/documentation/latest/configuration/) for details.

        :param accepted_resource_roles: The accepted_resource_roles of this Body.
        :type: list[str]
        """
        self._accepted_resource_roles = accepted_resource_roles

    @property
    def args(self):
        """
        Gets the args of this Body.
        An array of strings that represents an alternative mode of specifying the command to run. This was motivated by safe usage of containerizer features like a custom Docker ENTRYPOINT. This args field may be used in place of cmd even when using the default command executor. This change mirrors API and semantics changes in the Mesos CommandInfo protobuf message starting with version `0.20.0`.  Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same app.

        :return: The args of this Body.
        :rtype: list[str]
        """
        return self._args

    @args.setter
    def args(self, args):
        """
        Sets the args of this Body.
        An array of strings that represents an alternative mode of specifying the command to run. This was motivated by safe usage of containerizer features like a custom Docker ENTRYPOINT. This args field may be used in place of cmd even when using the default command executor. This change mirrors API and semantics changes in the Mesos CommandInfo protobuf message starting with version `0.20.0`.  Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same app.

        :param args: The args of this Body.
        :type: list[str]
        """
        self._args = args

    @property
    def backoff_factor(self):
        """
        Gets the backoff_factor of this Body.
        Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.

        :return: The backoff_factor of this Body.
        :rtype: float
        """
        return self._backoff_factor

    @backoff_factor.setter
    def backoff_factor(self, backoff_factor):
        """
        Sets the backoff_factor of this Body.
        Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.

        :param backoff_factor: The backoff_factor of this Body.
        :type: float
        """
        self._backoff_factor = backoff_factor

    @property
    def backoff_seconds(self):
        """
        Gets the backoff_seconds of this Body.
        Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.

        :return: The backoff_seconds of this Body.
        :rtype: int
        """
        return self._backoff_seconds

    @backoff_seconds.setter
    def backoff_seconds(self, backoff_seconds):
        """
        Sets the backoff_seconds of this Body.
        Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.

        :param backoff_seconds: The backoff_seconds of this Body.
        :type: int
        """
        self._backoff_seconds = backoff_seconds

    @property
    def cmd(self):
        """
        Gets the cmd of this Body.
        The command that is executed.  This value is wrapped by Mesos via `/bin/sh -c ${app.cmd}`.  Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same app.

        :return: The cmd of this Body.
        :rtype: str
        """
        return self._cmd

    @cmd.setter
    def cmd(self, cmd):
        """
        Sets the cmd of this Body.
        The command that is executed.  This value is wrapped by Mesos via `/bin/sh -c ${app.cmd}`.  Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same app.

        :param cmd: The cmd of this Body.
        :type: str
        """
        self._cmd = cmd

    @property
    def constraints(self):
        """
        Gets the constraints of this Body.
        Valid constraint operators are one of UNIQUE, CLUSTER, GROUP_BY, LIKE, UNLIKE.

        :return: The constraints of this Body.
        :rtype: list[list[ERRORUNKNOWN]]
        """
        return self._constraints

    @constraints.setter
    def constraints(self, constraints):
        """
        Sets the constraints of this Body.
        Valid constraint operators are one of UNIQUE, CLUSTER, GROUP_BY, LIKE, UNLIKE.

        :param constraints: The constraints of this Body.
        :type: list[list[ERRORUNKNOWN]]
        """
        self._constraints = constraints

    @property
    def container(self):
        """
        Gets the container of this Body.


        :return: The container of this Body.
        :rtype: V2appsContainer
        """
        return self._container

    @container.setter
    def container(self, container):
        """
        Sets the container of this Body.


        :param container: The container of this Body.
        :type: V2appsContainer
        """
        self._container = container

    @property
    def cpus(self):
        """
        Gets the cpus of this Body.
        The number of CPU shares this application needs per instance. This number does not have to be integer, but can be a fraction.

        :return: The cpus of this Body.
        :rtype: float
        """
        return self._cpus

    @cpus.setter
    def cpus(self, cpus):
        """
        Sets the cpus of this Body.
        The number of CPU shares this application needs per instance. This number does not have to be integer, but can be a fraction.

        :param cpus: The cpus of this Body.
        :type: float
        """
        self._cpus = cpus

    @property
    def dependencies(self):
        """
        Gets the dependencies of this Body.
        A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.

        :return: The dependencies of this Body.
        :rtype: list[PathType]
        """
        return self._dependencies

    @dependencies.setter
    def dependencies(self, dependencies):
        """
        Sets the dependencies of this Body.
        A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.

        :param dependencies: The dependencies of this Body.
        :type: list[PathType]
        """
        self._dependencies = dependencies

    @property
    def disk(self):
        """
        Gets the disk of this Body.
        How much disk space is needed for this application. This number does not have to be an integer, but can be a fraction.

        :return: The disk of this Body.
        :rtype: float
        """
        return self._disk

    @disk.setter
    def disk(self, disk):
        """
        Sets the disk of this Body.
        How much disk space is needed for this application. This number does not have to be an integer, but can be a fraction.

        :param disk: The disk of this Body.
        :type: float
        """
        self._disk = disk

    @property
    def env(self):
        """
        Gets the env of this Body.


        :return: The env of this Body.
        :rtype: object
        """
        return self._env

    @env.setter
    def env(self, env):
        """
        Sets the env of this Body.


        :param env: The env of this Body.
        :type: object
        """
        self._env = env

    @property
    def executor(self):
        """
        Gets the executor of this Body.
        The executor to use to launch this application. Different executors are available. The simplest one (and the default if none is given) is //cmd, which takes the cmd and executes that on the shell level.

        :return: The executor of this Body.
        :rtype: str
        """
        return self._executor

    @executor.setter
    def executor(self, executor):
        """
        Sets the executor of this Body.
        The executor to use to launch this application. Different executors are available. The simplest one (and the default if none is given) is //cmd, which takes the cmd and executes that on the shell level.

        :param executor: The executor of this Body.
        :type: str
        """
        self._executor = executor

    @property
    def fetch(self):
        """
        Gets the fetch of this Body.
        Provided URIs are passed to Mesos fetcher module and resolved in runtime.

        :return: The fetch of this Body.
        :rtype: list[V2appsFetch]
        """
        return self._fetch

    @fetch.setter
    def fetch(self, fetch):
        """
        Sets the fetch of this Body.
        Provided URIs are passed to Mesos fetcher module and resolved in runtime.

        :param fetch: The fetch of this Body.
        :type: list[V2appsFetch]
        """
        self._fetch = fetch

    @property
    def health_checks(self):
        """
        Gets the health_checks of this Body.


        :return: The health_checks of this Body.
        :rtype: list[V2appsHealthChecks]
        """
        return self._health_checks

    @health_checks.setter
    def health_checks(self, health_checks):
        """
        Sets the health_checks of this Body.


        :param health_checks: The health_checks of this Body.
        :type: list[V2appsHealthChecks]
        """
        self._health_checks = health_checks

    @property
    def id(self):
        """
        Gets the id of this Body.
        Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.

        :return: The id of this Body.
        :rtype: PathType
        """
        return self._id

    @id.setter
    def id(self, id):
        """
        Sets the id of this Body.
        Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.

        :param id: The id of this Body.
        :type: PathType
        """
        self._id = id

    @property
    def instances(self):
        """
        Gets the instances of this Body.
        The number of instances of this application to start. Please note: this number can be changed any time as needed to scale the application.

        :return: The instances of this Body.
        :rtype: int
        """
        return self._instances

    @instances.setter
    def instances(self, instances):
        """
        Sets the instances of this Body.
        The number of instances of this application to start. Please note: this number can be changed any time as needed to scale the application.

        :param instances: The instances of this Body.
        :type: int
        """
        self._instances = instances

    @property
    def labels(self):
        """
        Gets the labels of this Body.
        Attaching metadata to apps can be useful to expose additional information to other services, so we added the ability to place labels on apps (for example, you could label apps staging and production to mark services by their position in the pipeline).

        :return: The labels of this Body.
        :rtype: dict(str, str)
        """
        return self._labels

    @labels.setter
    def labels(self, labels):
        """
        Sets the labels of this Body.
        Attaching metadata to apps can be useful to expose additional information to other services, so we added the ability to place labels on apps (for example, you could label apps staging and production to mark services by their position in the pipeline).

        :param labels: The labels of this Body.
        :type: dict(str, str)
        """
        self._labels = labels

    @property
    def max_launch_delay_seconds(self):
        """
        Gets the max_launch_delay_seconds of this Body.
        Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.

        :return: The max_launch_delay_seconds of this Body.
        :rtype: int
        """
        return self._max_launch_delay_seconds

    @max_launch_delay_seconds.setter
    def max_launch_delay_seconds(self, max_launch_delay_seconds):
        """
        Sets the max_launch_delay_seconds of this Body.
        Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.

        :param max_launch_delay_seconds: The max_launch_delay_seconds of this Body.
        :type: int
        """
        self._max_launch_delay_seconds = max_launch_delay_seconds

    @property
    def mem(self):
        """
        Gets the mem of this Body.
        The amount of memory in MB that is needed for the application per instance.

        :return: The mem of this Body.
        :rtype: float
        """
        return self._mem

    @mem.setter
    def mem(self, mem):
        """
        Sets the mem of this Body.
        The amount of memory in MB that is needed for the application per instance.

        :param mem: The mem of this Body.
        :type: float
        """
        self._mem = mem

    @property
    def ip_address(self):
        """
        Gets the ip_address of this Body.


        :return: The ip_address of this Body.
        :rtype: V2appsIpAddress
        """
        return self._ip_address

    @ip_address.setter
    def ip_address(self, ip_address):
        """
        Sets the ip_address of this Body.


        :param ip_address: The ip_address of this Body.
        :type: V2appsIpAddress
        """
        self._ip_address = ip_address

    @property
    def ports(self):
        """
        Gets the ports of this Body.
        An array of required port resources on the agent host. The number of items in the array determines how many dynamic ports are allocated for every task. For every port that is zero, a globally unique (cluster-wide) port is assigned and provided as part of the app definition to be used in load balancing definitions.

        :return: The ports of this Body.
        :rtype: list[int]
        """
        return self._ports

    @ports.setter
    def ports(self, ports):
        """
        Sets the ports of this Body.
        An array of required port resources on the agent host. The number of items in the array determines how many dynamic ports are allocated for every task. For every port that is zero, a globally unique (cluster-wide) port is assigned and provided as part of the app definition to be used in load balancing definitions.

        :param ports: The ports of this Body.
        :type: list[int]
        """
        self._ports = ports

    @property
    def residency(self):
        """
        Gets the residency of this Body.


        :return: The residency of this Body.
        :rtype: V2appsResidency
        """
        return self._residency

    @residency.setter
    def residency(self, residency):
        """
        Sets the residency of this Body.


        :param residency: The residency of this Body.
        :type: V2appsResidency
        """
        self._residency = residency

    @property
    def require_ports(self):
        """
        Gets the require_ports of this Body.
        Normally, the host ports of your tasks are automatically assigned. This corresponds to the requirePorts value false which is the default. If you need more control and want to specify your host ports in advance, you can set requirePorts to true. This way the ports you have specified are used as host ports. That also means that Marathon can schedule the associated tasks only on hosts that have the specified ports available.

        :return: The require_ports of this Body.
        :rtype: bool
        """
        return self._require_ports

    @require_ports.setter
    def require_ports(self, require_ports):
        """
        Sets the require_ports of this Body.
        Normally, the host ports of your tasks are automatically assigned. This corresponds to the requirePorts value false which is the default. If you need more control and want to specify your host ports in advance, you can set requirePorts to true. This way the ports you have specified are used as host ports. That also means that Marathon can schedule the associated tasks only on hosts that have the specified ports available.

        :param require_ports: The require_ports of this Body.
        :type: bool
        """
        self._require_ports = require_ports

    @property
    def store_urls(self):
        """
        Gets the store_urls of this Body.
        URL's that have to be resolved and put into the artifact store, before the task will be started.

        :return: The store_urls of this Body.
        :rtype: list[str]
        """
        return self._store_urls

    @store_urls.setter
    def store_urls(self, store_urls):
        """
        Sets the store_urls of this Body.
        URL's that have to be resolved and put into the artifact store, before the task will be started.

        :param store_urls: The store_urls of this Body.
        :type: list[str]
        """
        self._store_urls = store_urls

    @property
    def upgrade_strategy(self):
        """
        Gets the upgrade_strategy of this Body.


        :return: The upgrade_strategy of this Body.
        :rtype: V2appsUpgradeStrategy
        """
        return self._upgrade_strategy

    @upgrade_strategy.setter
    def upgrade_strategy(self, upgrade_strategy):
        """
        Sets the upgrade_strategy of this Body.


        :param upgrade_strategy: The upgrade_strategy of this Body.
        :type: V2appsUpgradeStrategy
        """
        self._upgrade_strategy = upgrade_strategy

    @property
    def uris(self):
        """
        Gets the uris of this Body.
        URIs defined here are resolved, before the application gets started. If the application has external dependencies, they should be defined here.

        :return: The uris of this Body.
        :rtype: list[str]
        """
        return self._uris

    @uris.setter
    def uris(self, uris):
        """
        Sets the uris of this Body.
        URIs defined here are resolved, before the application gets started. If the application has external dependencies, they should be defined here.

        :param uris: The uris of this Body.
        :type: list[str]
        """
        self._uris = uris

    @property
    def user(self):
        """
        Gets the user of this Body.
        The user to use to run the tasks on the agent.

        :return: The user of this Body.
        :rtype: str
        """
        return self._user

    @user.setter
    def user(self, user):
        """
        Sets the user of this Body.
        The user to use to run the tasks on the agent.

        :param user: The user of this Body.
        :type: str
        """
        self._user = user

    @property
    def version(self):
        """
        Gets the version of this Body.
        The version of this definition.

        :return: The version of this Body.
        :rtype: datetime
        """
        return self._version

    @version.setter
    def version(self, version):
        """
        Sets the version of this Body.
        The version of this definition.

        :param version: The version of this Body.
        :type: datetime
        """
        self._version = version

    @property
    def version_info(self):
        """
        Gets the version_info of this Body.


        :return: The version_info of this Body.
        :rtype: V2appsVersionInfo
        """
        return self._version_info

    @version_info.setter
    def version_info(self, version_info):
        """
        Sets the version_info of this Body.


        :param version_info: The version_info of this Body.
        :type: V2appsVersionInfo
        """
        self._version_info = version_info

    def to_dict(self):
        """
        Returns the model properties as a dict
        """
        result = {}

        for attr, _ in iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            else:
                result[attr] = value

        return result

    def to_str(self):
        """
        Returns the string representation of the model
        """
        return pformat(self.to_dict())

    def __repr__(self):
        """
        For `print` and `pprint`
        """
        return self.to_str()

    def __eq__(self, other): 
        """
        Returns true if both objects are equal
        """
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """ 
        Returns true if both objects are not equal
        """
        return not self == other

