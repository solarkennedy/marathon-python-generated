#%RAML 0.8
title: Marathon REST
version: '2.0'
baseUri: null../
mediaType: application/json
protocols:
  - HTTP
documentation:
  - title: Marathon REST
    content: ''
/v2:
  displayName: v2
  description: ''
  /apps:
    displayName: apps
    description: ''
    uriParameters: {}
    get:
      description: Get the list of running applications. Several filters can be applied via the following query parameters.
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "apps": [
                        {
                            "id": "/myapp",
                            "cmd": "env && sleep 60",
                            "args": null,
                            "user": null,
                            "env": {
                                "LD_LIBRARY_PATH": "/usr/local/lib/myLib"
                            },
                            "instances": 3,
                            "cpus": 0.1,
                            "mem": 5,
                            "disk": 0,
                            "executor": "",
                            "constraints": [
                                [
                                    "hostname",
                                    "UNIQUE",
                                    ""
                                ]
                            ],
                            "uris": [
                                "https://raw.github.com/mesosphere/marathon/master/README.md"
                            ],
                            "storeUrls": [],
                            "ports": [
                                10013,
                                10015
                            ],
                            "requirePorts": false,
                            "backoffSeconds": 1,
                            "backoffFactor": 1.15,
                            "maxLaunchDelaySeconds": 3600,
                            "container": null,
                            "healthChecks": [],
                            "dependencies": [],
                            "upgradeStrategy": {
                                "minimumHealthCapacity": 1,
                                "maximumOverCapacity": 1
                            },
                            "labels": {},
                            "acceptedResourceRoles": null,
                            "version": "2015-09-25T15:13:48.343Z",
                            "versionInfo": {
                                "lastScalingAt": "2015-09-25T15:13:48.343Z",
                                "lastConfigChangeAt": "2015-09-25T15:13:48.343Z"
                            },
                            "tasksStaged": 0,
                            "tasksRunning": 0,
                            "tasksHealthy": 0,
                            "tasksUnhealthy": 0,
                            "deployments": [
                                {
                                    "id": "9538079c-3898-4e32-aa31-799bf9097f74"
                                }
                            ]
                        }
                    ]
                }
          description: The list of applications that match the defined filters
        '401':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid username or password."
                }
          description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
        '403':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Not Authorized to perform this action!"
                }
          description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
      queryParameters:
        cmd:
          type: string
          description: Filter the result to only return apps whose `cmd` field contains the given value
          required: false
          example: java
          displayName: cmd
        id:
          type: string
          description: Filter the result to only return apps whose `id` is or contains the given value
          required: false
          example: /us-east/database/memsql
          displayName: id
        label:
          type: string
          description: |-
            A label selector query contains one or more label selectors, which are comma separated. Marathon supports three types of selectors existence-based, equality-based and set-based. In the case of multiple selectors, all must be satisfied so comma separator acts as an AND logical operator. Labels and values must consist of alphanumeric characters plus `-` `_` and `.` `-A-Za-z0-9_.`. Any other character is possible, but must be escaped with a backslash character.
            * <code>Existence based Selector Query</code> Matches the existence of a label <br/> Example&#58; my_label,environment
            * <code>Equality based Selector Query</code> Matches existence of labels and the (non) equality of the value.<br/> Example&#58; environment==production, tier!=frontend
            * <code>Set based Selector Query</code> Matches existence of labels and the (non) existence of the value in a given set<br/> Example&#58; environment in (stage,production), tier notin (frontend, service)
          required: false
          example: "my_label, environment==production, tier!=frontend\\ tier, deployed in (us, eu), deployed notin (aa, bb)"
          displayName: label
        embed:
          type: string
          description: |-
            Embeds nested resources that match the supplied path. You can specify this parameter multiple times with different values.
            - <code>apps.tasks</code> embed all tasks of each application<br/> Note&#58; if this embed is definded, it automatically sets <code>apps.deployments</code> but this will change in a future release. Please define all embeds explicitly.
            - <code>apps.counts</code> embed all task counts (tasksStaged, tasksRunning, tasksHealthy, tasksUnhealthy) <br/> Note&#58; currently embedded by default but this will change in a future release. Please define all embeds explicitly.
            - <code>apps.deployments</code> embed all deployment identifier, if the related app currently is in deployment.
            - <code>apps.lastTaskFailure</code> embeds the lastTaskFailure for the application if there is one.
            - <code>apps.failures</code> Shorthand for apps.lastTaskFailure, apps.tasks, apps.counts and apps.deployments.<br/> Note&#58; deprecated and will be removed in future versions Please define all embeds explicitly.
            - <code>apps.taskStats</code> exposes task statatistics in the JSON.
          required: false
          enum:
            - apps.tasks
            - apps.count
            - apps.deployments
            - apps.lastTaskFailure
            - apps.failures
            - apps.taskStats
          example: apps.tasks
          displayName: embed
    put:
      description: |-
        Change multiple applications either by upgrading existing ones or creating new ones. If there is an update to an already running application, the application gets upgraded. All instances of this application get replaced by the new version. The order of dependencies will be applied correctly. The upgradeStrategy defines the behaviour of the upgrade.
        If the id of the application is not known, the application gets started. The order of dependencies will be applied correctly. It is possible to mix upgrades and installs.
        If you have more complex scenarios with upgrades, use the groups endpoint.
        Note&#58;  This operation will create a deployment. The operation finishes, if the deployment succeeds. You can query the deployments endoint to see the status of the deployment.
      body:
        application/json:
          example: |-
            [
                {
                    "id": "/test/sleep60",
                    "cmd": "sleep 60",
                    "cpus": 0.3,
                    "instances": 2,
                    "mem": 9,
                    "dependencies": [
                        "/test/sleep120",
                        "/other/namespace/or/app"
                    ]
                },
                {
                    "id": "/test/sleep120",
                    "cmd": "sleep 120",
                    "cpus": 0.3,
                    "instances": 2,
                    "mem": 9
                }
            ]
          schema: '{}'
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "deploymentId": "5ed4c0c5-9ff8-4a6f-a0cd-f57f59a34b43",
                    "version": "2015-09-29T15:59:51.164Z"
                }
          description: 'A deployment is started which has a unique deployment identifier. The related deployment can be fetched from the /v2/deployments endpoint. If the deployement is gone from the list of deployments, than this means it is finished. As long as the deployment runs, the effect of that change operation is visible only partially.'
        '400':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid JSON",
                    "details": [
                        {
                            "path": "/id",
                            "errors": [
                                "error.expected.jsstring"
                            ]
                        }
                    ]
                }
          description: The application definition provided in the body is not valid.
        '401':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid username or password."
                }
          description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
        '403':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Not Authorized to perform this action!"
                }
          description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
        '409':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "An app with id [/existing_app] already exists."
                }
          description: There is an already deployed application with this name
        '422':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Object is not valid",
                    "details": [
                        {
                            "attribute": "upgradeStrategy.minimumHealthCapacity",
                            "error": "is greater than 1"
                        }
                    ]
                }
          description: 'The entity send can not be preocessed, since there are validation errors'
      queryParameters:
        force:
          type: boolean
          description: |-
            Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
            Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
          required: false
          displayName: force
    post:
      description: |-
        Create and start a new application.
        Note&#58;  This operation will create a deployment. The operation finishes, if the deployment succeeds. You can query the deployments endoint to see the status of the deployment.
      body:
        application/json:
          example: |-
            {
                "id": "/foo",
                "instances": 2,
                "cmd": "sleep 1000",
                "cpus": 0.1,
                "disk": 0,
                "mem": 16,
                "acceptedResourceRoles": [
                    "mesos_role"
                ],
                "args": [
                    "sleep",
                    "100"
                ],
                "backoffFactor": 1.15,
                "backoffSeconds": 1,
                "constraints": [
                    [
                        "hostname",
                        "LIKE",
                        "srv2.*"
                    ]
                ],
                "container": {
                    "docker": {
                        "forcePullImage": false,
                        "image": "mesosphere:marathon/latest",
                        "network": "BRIDGE",
                        "parameters": [
                            {
                                "key": "name",
                                "value": "kdc"
                            }
                        ],
                        "portMappings": [
                            {
                                "containerPort": 80,
                                "hostPort": 0,
                                "protocol": "tcp",
                                "servicePort": 10019
                            }
                        ],
                        "privileged": false
                    },
                    "type": "DOCKER",
                    "volumes": [
                        {
                            "containerPath": "/docker_storage",
                            "hostPath": "/hdd/tools/docker/registry",
                            "mode": "RW"
                        }
                    ]
                },
                "dependencies": [
                    "/prod/group"
                ],
                "env": {
                    "XPS1": "Test",
                    "XPS2": "Rest"
                },
                "executor": "",
                "healthChecks": [
                    {
                        "gracePeriodSeconds": 300,
                        "ignoreHttp1xx": false,
                        "intervalSeconds": 20,
                        "maxConsecutiveFailures": 3,
                        "path": "/",
                        "portIndex": 0,
                        "protocol": "HTTP",
                        "timeoutSeconds": 20
                    }
                ],
                "labels": {
                    "owner": "zeus",
                    "note": "Away from olympus"
                },
                "maxLaunchDelaySeconds": 3600,
                "ipAddress": {
                    "discovery": {
                        "ports": [
                            {
                                "number": 8080,
                                "name": "rest_endpoint",
                                "protocol": "tcp"
                            }
                        ]
                    },
                    "groups": [
                        "dev"
                    ],
                    "labels": {
                        "environment": "dev"
                    }
                },
                "ports": [
                    0
                ],
                "requirePorts": false,
                "upgradeStrategy": {
                    "maximumOverCapacity": 1,
                    "minimumHealthCapacity": 1
                },
                "fetch": [
                    {
                        "uri": "https://foo.com/setup.py"
                    },
                    {
                        "uri": "https://foo.com/archive.zip",
                        "executable": false,
                        "extract": true,
                        "cache": true
                    }
                ],
                "user": "root"
            }
          schema: "{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"additionalProperties\": false,\n    \"definitions\": {\n        \"pathType\": {\n            \"type\": \"string\",\n            \"pattern\": \"^(\\\\/?((\\\\.{2})|([a-z0-9][a-z0-9\\\\-.]*[a-z0-9]+)|([a-z0-9]*))($|\\\\/))+$\",\n            \"minLength\": 1\n        }\n    },\n    \"not\": {\n        \"allOf\": [\n            {\n                \"required\": [\n                    \"cmd\"\n                ]\n            },\n            {\n                \"required\": [\n                    \"args\"\n                ]\n            }\n        ]\n    },\n    \"properties\": {\n        \"acceptedResourceRoles\": {\n            \"items\": {\n                \"type\": \"string\"\n            },\n            \"type\": \"array\",\n            \"description\": \"Optional. A list of resource roles. Marathon considers only resource offers with roles in this list for launching tasks of this app. If you do not specify this, Marathon considers all resource offers with roles that have been configured by the `--default_accepted_resource_roles` command line flag. If no `--default_accepted_resource_roles` was given on startup, Marathon considers all resource offers. To register Marathon for a role, you need to specify the `--mesos_role` command line flag on startup. If you want to assign all resources of a slave to a role, you can use the `--default_role` argument when starting up the slave. If you need a more fine-grained configuration, you can use the `--resources` argument to specify resource shares per role. The Mesos master needs to be started with `--roles` followed by a comma-separated list of all roles you want to use across your cluster. See [the Mesos command line documentation](http://mesos.apache.org/documentation/latest/configuration/) for details.\"\n        },\n        \"args\": {\n            \"items\": {\n                \"type\": \"string\"\n            },\n            \"type\": \"array\",\n            \"description\": \"An array of strings that represents an alternative mode of specifying the command to run. This was motivated by safe usage of containerizer features like a custom Docker ENTRYPOINT. This args field may be used in place of cmd even when using the default command executor. This change mirrors API and semantics changes in the Mesos CommandInfo protobuf message starting with version `0.20.0`.  Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same app.\"\n        },\n        \"backoffFactor\": {\n            \"minimum\": 1,\n            \"type\": \"number\",\n            \"description\": \"Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.\"\n        },\n        \"backoffSeconds\": {\n            \"description\": \"Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.\",\n            \"minimum\": 0,\n            \"type\": \"integer\"\n        },\n        \"cmd\": {\n            \"description\": \"The command that is executed.  This value is wrapped by Mesos via `/bin/sh -c ${app.cmd}`.  Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same app.\",\n            \"type\": \"string\",\n            \"minLength\": 1\n        },\n        \"constraints\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"array\",\n                \"items\": [\n                    {\n                        \"type\": \"string\"\n                    },\n                    {\n                        \"type\": \"string\",\n                        \"enum\": [\n                            \"UNIQUE\",\n                            \"CLUSTER\",\n                            \"GROUP_BY\",\n                            \"LIKE\",\n                            \"UNLIKE\"\n                        ]\n                    },\n                    {\n                        \"type\": \"string\"\n                    }\n                ],\n                \"minItems\": 2,\n                \"additionalItems\": false\n            },\n            \"description\": \"Valid constraint operators are one of UNIQUE, CLUSTER, GROUP_BY, LIKE, UNLIKE.\"\n        },\n        \"container\": {\n            \"additionalProperties\": false,\n            \"properties\": {\n                \"docker\": {\n                    \"additionalProperties\": false,\n                    \"properties\": {\n                        \"forcePullImage\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"The container will be pulled, regardless if it is already available on the local system.\"\n                        },\n                        \"image\": {\n                            \"type\": \"string\",\n                            \"minLength\": 1,\n                            \"description\": \"The name of the docker image to use.\"\n                        },\n                        \"network\": {\n                            \"type\": \"string\",\n                            \"description\": \"The networking mode, this container should operate in. One of BRIDGED|HOST|NONE\",\n                            \"enum\": [\n                                \"BRIDGE\",\n                                \"HOST\",\n                                \"NONE\"\n                            ]\n                        },\n                        \"parameters\": {\n                            \"type\": \"array\",\n                            \"description\": \"Allowing arbitrary parameters to be passed to docker CLI. Note that anything passed to this field is not guaranteed to be supported moving forward, as we might move away from the docker CLI.\",\n                            \"items\": {\n                                \"type\": \"object\",\n                                \"additionalProperties\": false,\n                                \"properties\": {\n                                    \"key\": {\n                                        \"type\": \"string\",\n                                        \"minLength\": 1,\n                                        \"description\": \"Key of this parameter\"\n                                    },\n                                    \"value\": {\n                                        \"type\": \"string\",\n                                        \"description\": \"Value of this parameter\"\n                                    }\n                                },\n                                \"required\": [\n                                    \"key\",\n                                    \"value\"\n                                ]\n                            }\n                        },\n                        \"portMappings\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"object\",\n                                \"additionalProperties\": false,\n                                \"properties\": {\n                                    \"containerPort\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Refers to the port the application listens to inside of the container. It is optional and now defaults to 0, in which case Marathon assigns the container port the same value as the assigned hostPort. This is especially useful for apps that advertise the port they are listening on to the outside world for P2P communication. Without containerPort: 0 they would erroneously advertise their private container port which is usually not the same as the externally visible host port.\",\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0\n                                    },\n                                    \"hostPort\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Retains the traditional meaning in Marathon, which is a random port from the range included in the Mesos resource offer. The resulting host ports for each task are exposed via the task details in the REST API and the Marathon web UI. hostPort is optional and defaults to 0.\",\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0\n                                    },\n                                    \"protocol\": {\n                                        \"type\": \"string\",\n                                        \"description\": \"parameter is optional and defaults to tcp.\"\n                                    },\n                                    \"servicePort\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Is a helper port intended for doing service discovery using a well-known port per service. The assigned servicePort value is not used/interpreted by Marathon itself but supposed to used by load balancer infrastructure. See Service Discovery Load Balancing doc page. The servicePort parameter is optional and defaults to 0. Like hostPort, If the value is 0, a random port will be assigned. If a servicePort value is assigned by Marathon then Marathon guarantees that its value is unique across the cluster. The values for random service ports are in the range [local_port_min, local_port_max] where local_port_min and local_port_max are command line options with default values of 10000 and 20000, respectively.\",\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0\n                                    }\n                                }\n                            }\n                        },\n                        \"privileged\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Run this docker image in privileged mode.\"\n                        }\n                    },\n                    \"required\": [\n                        \"image\"\n                    ],\n                    \"type\": \"object\"\n                },\n                \"type\": {\n                    \"type\": \"string\",\n                    \"description\": \"Supported container types at the moment are DOCKER and MESOS.\",\n                    \"enum\": [\n                        \"MESOS\",\n                        \"DOCKER\"\n                    ]\n                },\n                \"volumes\": {\n                    \"items\": {\n                        \"additionalProperties\": false,\n                        \"properties\": {\n                            \"containerPath\": {\n                                \"type\": \"string\",\n                                \"description\": \"The path of the volume in the container\",\n                                \"minLength\": 1\n                            },\n                            \"hostPath\": {\n                                \"type\": \"string\",\n                                \"description\": \"The path of the volume on the host\",\n                                \"minLength\": 1\n                            },\n                            \"persistent\": {\n                                \"additionalProperties\": false,\n                                \"properties\": {\n                                    \"size\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"The size of the persistent volume in MiB\",\n                                        \"minimum\": 0\n                                    }\n                                },\n                                \"type\": \"object\"\n                            },\n                            \"mode\": {\n                                \"type\": \"string\",\n                                \"description\": \"Possible values are RO for ReadOnly and RW for Read/Write\",\n                                \"enum\": [\n                                    \"RO\",\n                                    \"RW\"\n                                ]\n                            }\n                        },\n                        \"type\": \"object\"\n                    },\n                    \"type\": \"array\"\n                }\n            },\n            \"type\": \"object\"\n        },\n        \"cpus\": {\n            \"type\": \"number\",\n            \"description\": \"The number of CPU shares this application needs per instance. This number does not have to be integer, but can be a fraction.\",\n            \"minimum\": 0\n        },\n        \"dependencies\": {\n            \"type\": \"array\",\n            \"description\": \"A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.\",\n            \"items\": {\n                \"$ref\": \"#/definitions/pathType\"\n            }\n        },\n        \"disk\": {\n            \"type\": \"number\",\n            \"description\": \"How much disk space is needed for this application. This number does not have to be an integer, but can be a fraction.\",\n            \"minimum\": 0\n        },\n        \"env\": {\n            \"patternProperties\": {\n                \".*\": {\n                    \"type\": \"string\"\n                }\n            },\n            \"type\": \"object\"\n        },\n        \"executor\": {\n            \"type\": \"string\",\n            \"description\": \"The executor to use to launch this application. Different executors are available. The simplest one (and the default if none is given) is //cmd, which takes the cmd and executes that on the shell level.\",\n            \"pattern\": \"^(|\\\\/\\\\/cmd|\\\\/?[^\\\\/]+(\\\\/[^\\\\/]+)*)$\"\n        },\n        \"fetch\": {\n            \"type\": \"array\",\n            \"description\": \"Provided URIs are passed to Mesos fetcher module and resolved in runtime.\",\n            \"items\": {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"properties\": {\n                    \"uri\": {\n                        \"type\": \"string\",\n                        \"description\": \"URI to be fetched by Mesos fetcher module\"\n                    },\n                    \"executable\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Set fetched artifact as executable\"\n                    },\n                    \"extract\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Extract fetched artifact if supported by Mesos fetcher module\"\n                    },\n                    \"cache\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Cache fetched artifact if supported by Mesos fetcher module\"\n                    }\n                },\n                \"required\": [\n                    \"uri\"\n                ]\n            }\n        },\n        \"healthChecks\": {\n            \"items\": {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"properties\": {\n                    \"command\": {\n                        \"type\": \"object\",\n                        \"items\": {\n                            \"additionalProperties\": false,\n                            \"properties\": {\n                                \"value\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"The health check command to execute.\"\n                                }\n                            }\n                        }\n                    },\n                    \"gracePeriodSeconds\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Health check failures are ignored within this number of seconds of the task being started or until the task becomes healthy for the first time.\",\n                        \"minimum\": 0\n                    },\n                    \"ignoreHttp1xx\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Ignore HTTP 1xx responses.\"\n                    },\n                    \"intervalSeconds\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Number of seconds to wait between health checks.\",\n                        \"minimum\": 0\n                    },\n                    \"maxConsecutiveFailures\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Number of consecutive health check failures after which the unhealthy task should be killed.\",\n                        \"minimum\": 0\n                    },\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"Path to endpoint exposed by the task that will provide health status. Example: /path/to/health. Note: only used if protocol == HTTP[S].\"\n                    },\n                    \"port\": {\n                        \"type\": \"integer\",\n                        \"description\": \"The specific port to connect to. In case of dynamic ports, see portIndex.\",\n                        \"maximum\": 65535,\n                        \"minimum\": 0\n                    },\n                    \"portIndex\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Index in this app's ports array to be used for health requests. An index is used so the app can use random ports, like [0, 0, 0] for example, and tasks could be started with port environment variables like $PORT1.\",\n                        \"minimum\": 0\n                    },\n                    \"protocol\": {\n                        \"type\": \"string\",\n                        \"description\": \"Protocol of the requests to be performed. One of HTTP, HTTPS, TCP or COMMAND.\",\n                        \"enum\": [\n                            \"HTTP\",\n                            \"HTTPS\",\n                            \"TCP\",\n                            \"COMMAND\"\n                        ]\n                    },\n                    \"timeoutSeconds\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Number of seconds after which a health check is considered a failure regardless of the response.\",\n                        \"minimum\": 0\n                    }\n                }\n            },\n            \"type\": \"array\"\n        },\n        \"id\": {\n            \"$ref\": \"#/definitions/pathType\",\n            \"description\": \"Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.\"\n        },\n        \"instances\": {\n            \"type\": \"integer\",\n            \"description\": \"The number of instances of this application to start. Please note: this number can be changed any time as needed to scale the application.\",\n            \"minimum\": 0\n        },\n        \"labels\": {\n            \"type\": \"object\",\n            \"description\": \"Attaching metadata to apps can be useful to expose additional information to other services, so we added the ability to place labels on apps (for example, you could label apps staging and production to mark services by their position in the pipeline).\",\n            \"additionalProperties\": {\n                \"type\": \"string\"\n            }\n        },\n        \"maxLaunchDelaySeconds\": {\n            \"type\": \"integer\",\n            \"description\": \"Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.\",\n            \"minimum\": 0\n        },\n        \"mem\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of memory in MB that is needed for the application per instance.\",\n            \"minimum\": 0\n        },\n        \"ipAddress\": {\n            \"type\": \"object\",\n            \"description\": \"If an application definition includes the 'ipAddress' field, then Marathon will request a per-task IP from Mesos. A separate ports/portMappings configuration is then disallowed.\",\n            \"properties\": {\n                \"discovery\": {\n                    \"type\": \"object\",\n                    \"description\": \"Information useful for service discovery.\",\n                    \"properties\": {\n                        \"ports\": {\n                            \"type\": \"array\",\n                            \"description\": \"Array of objects describing the ports exposed by each task.\",\n                            \"items\": {\n                                \"type\": \"object\",\n                                \"description\": \"Port\",\n                                \"properties\": {\n                                    \"number\": {\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0,\n                                        \"type\": \"integer\",\n                                        \"description\": \"The port number.\"\n                                    },\n                                    \"name\": {\n                                        \"type\": \"string\",\n                                        \"description\": \"Name of the port.\",\n                                        \"pattern\": \"^[a-z][a-z0-9-]*$\"\n                                    },\n                                    \"protocol\": {\n                                        \"enum\": [\n                                            \"tcp\",\n                                            \"udp\"\n                                        ],\n                                        \"description\": \"Protocol of the port (one of ['tcp', 'udp']).\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n                \"groups\": {\n                    \"type\": \"array\",\n                    \"description\": \"Array of network groups. One IP address can belong to zero or more network groups. The idea is that containers can only reach containers with which they share at least one network group.\",\n                    \"items\": {\n                        \"type\": \"string\",\n                        \"description\": \"The name of the network group.\"\n                    }\n                },\n                \"labels\": {\n                    \"type\": \"object\",\n                    \"description\": \"Key value pair for meta data on that network interface.\",\n                    \"properties\": {},\n                    \"additionalProperties\": true\n                }\n            }\n        },\n        \"ports\": {\n            \"type\": \"array\",\n            \"description\": \"An array of required port resources on the agent host. The number of items in the array determines how many dynamic ports are allocated for every task. For every port that is zero, a globally unique (cluster-wide) port is assigned and provided as part of the app definition to be used in load balancing definitions.\",\n            \"items\": {\n                \"maximum\": 65535,\n                \"minimum\": 0,\n                \"type\": \"integer\"\n            }\n        },\n        \"residency\": {\n            \"type\": \"object\",\n            \"description\": \"When using local persistent volumes that pin tasks onto agents, these values define how Marathon handles terminal states of these tasks.\",\n            \"properties\": {\n                \"relaunchEscalationTimeoutSeconds\": {\n                    \"type\": \"integer\",\n                    \"description\": \"When a task using persistent local volumes cannot be restarted on the agent it's been pinned to, Marathon will try to launch this task on another node after this timeout. Defaults to 3600 (one hour).\",\n                    \"minimum\": 0,\n                    \"additionalProperties\": false\n                },\n                \"taskLostBehavior\": {\n                    \"type\": \"string\",\n                    \"description\": \"When Marathon receives a TASK_LOST status update indicating that the agent running the task is gone, this property defines whether Marathon will launch the task on another node or not. Defaults to WAIT_FOREVER\",\n                    \"enum\": [\n                        \"WAIT_FOREVER\",\n                        \"RELAUNCH_AFTER_TIMEOUT\"\n                    ],\n                    \"additionalProperties\": false\n                }\n            },\n            \"additionalProperties\": false\n        },\n        \"requirePorts\": {\n            \"type\": \"boolean\",\n            \"description\": \"Normally, the host ports of your tasks are automatically assigned. This corresponds to the requirePorts value false which is the default. If you need more control and want to specify your host ports in advance, you can set requirePorts to true. This way the ports you have specified are used as host ports. That also means that Marathon can schedule the associated tasks only on hosts that have the specified ports available.\"\n        },\n        \"storeUrls\": {\n            \"type\": \"array\",\n            \"description\": \"URL's that have to be resolved and put into the artifact store, before the task will be started.\",\n            \"items\": {\n                \"type\": \"string\",\n                \"minLength\": 1\n            }\n        },\n        \"upgradeStrategy\": {\n            \"type\": \"object\",\n            \"description\": \"During an upgrade all instances of an application get replaced by a new version. The upgradeStrategy controls how Marathon stops old versions and launches new versions.\",\n            \"additionalProperties\": false,\n            \"properties\": {\n                \"maximumOverCapacity\": {\n                    \"type\": \"number\",\n                    \"description\": \"A number between 0 and 1 which is multiplied with the instance count. This is the maximum number of additional instances launched at any point of time during the upgrade process.\",\n                    \"maximum\": 1,\n                    \"minimum\": 0\n                },\n                \"minimumHealthCapacity\": {\n                    \"type\": \"number\",\n                    \"description\": \"A number between 0 and 1 that is multiplied with the instance count. This is the minimum number of healthy nodes that do not sacrifice overall application purpose. Marathon will make sure, during the upgrade process, that at any point of time this number of healthy instances are up.\",\n                    \"maximum\": 1,\n                    \"minimum\": 0\n                }\n            }\n        },\n        \"uris\": {\n            \"type\": \"array\",\n            \"description\": \"URIs defined here are resolved, before the application gets started. If the application has external dependencies, they should be defined here.\",\n            \"items\": {\n                \"type\": \"string\",\n                \"minLength\": 1\n            }\n        },\n        \"user\": {\n            \"type\": \"string\",\n            \"description\": \"The user to use to run the tasks on the agent.\"\n        },\n        \"version\": {\n            \"type\": \"string\",\n            \"description\": \"The version of this definition.\",\n            \"format\": \"date-time\"\n        },\n        \"versionInfo\": {\n            \"type\": \"object\",\n            \"description\": \"Detailed version information.\",\n            \"additionalProperties\": false,\n            \"properties\": {\n                \"lastScalingAt\": {\n                    \"type\": \"string\",\n                    \"description\": \"Contains the time stamp of the last change to this app which was not simply a scaling or a restarting configuration.\",\n                    \"format\": \"date-time\"\n                },\n                \"lastConfigChangeAt\": {\n                    \"type\": \"string\",\n                    \"description\": \"Contains the time stamp of the last change including changes like scaling or restarting the app. Since our versions are time based, this is currently equal to version.\",\n                    \"format\": \"date-time\"\n                }\n            }\n        }\n    },\n    \"required\": [\n        \"id\"\n    ],\n    \"type\": \"object\"\n}"
      responses:
        '201':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "id": "/foo",
                    "instances": 2,
                    "cmd": "sleep 1000",
                    "cpus": 0.1,
                    "disk": 0,
                    "mem": 16,
                    "acceptedResourceRoles": [
                        "mesos_role"
                    ],
                    "args": [
                        "sleep",
                        "100"
                    ],
                    "backoffFactor": 1.15,
                    "backoffSeconds": 1,
                    "constraints": [
                        [
                            "hostname",
                            "LIKE",
                            "srv2.*"
                        ]
                    ],
                    "container": {
                        "docker": {
                            "forcePullImage": false,
                            "image": "mesosphere:marathon/latest",
                            "network": "BRIDGE",
                            "parameters": [
                                {
                                    "key": "name",
                                    "value": "kdc"
                                }
                            ],
                            "portMappings": [
                                {
                                    "containerPort": 80,
                                    "hostPort": 0,
                                    "protocol": "tcp",
                                    "servicePort": 10019
                                }
                            ],
                            "privileged": false
                        },
                        "type": "DOCKER",
                        "volumes": [
                            {
                                "containerPath": "/docker_storage",
                                "hostPath": "/hdd/tools/docker/registry",
                                "mode": "RW"
                            }
                        ]
                    },
                    "dependencies": [
                        "/prod/group"
                    ],
                    "env": {
                        "XPS1": "Test",
                        "XPS2": "Rest"
                    },
                    "executor": "",
                    "healthChecks": [
                        {
                            "gracePeriodSeconds": 300,
                            "ignoreHttp1xx": false,
                            "intervalSeconds": 20,
                            "maxConsecutiveFailures": 3,
                            "path": "/",
                            "portIndex": 0,
                            "protocol": "HTTP",
                            "timeoutSeconds": 20
                        }
                    ],
                    "labels": {
                        "owner": "zeus",
                        "note": "Away from olympus"
                    },
                    "maxLaunchDelaySeconds": 3600,
                    "ipAddress": {
                        "discovery": {
                            "ports": [
                                {
                                    "number": 8080,
                                    "name": "rest_endpoint",
                                    "protocol": "tcp"
                                }
                            ]
                        },
                        "groups": [
                            "dev"
                        ],
                        "labels": {
                            "environment": "dev"
                        }
                    },
                    "ports": [
                        0
                    ],
                    "requirePorts": false,
                    "upgradeStrategy": {
                        "maximumOverCapacity": 1,
                        "minimumHealthCapacity": 1
                    },
                    "fetch": [
                        {
                            "uri": "https://foo.com/setup.py"
                        },
                        {
                            "uri": "https://foo.com/archive.zip",
                            "executable": false,
                            "extract": true,
                            "cache": true
                        }
                    ],
                    "user": "root"
                }
          description: The application has been created and a deployment is started.
        '400':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid JSON",
                    "details": [
                        {
                            "path": "/id",
                            "errors": [
                                "error.expected.jsstring"
                            ]
                        }
                    ]
                }
          description: The application definition provided in the body is not valid.
        '401':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid username or password."
                }
          description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
        '403':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Not Authorized to perform this action!"
                }
          description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
        '409':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "An app with id [/existing_app] already exists."
                }
          description: There is an already deployed application with this name
        '422':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Object is not valid",
                    "details": [
                        {
                            "attribute": "upgradeStrategy.minimumHealthCapacity",
                            "error": "is greater than 1"
                        }
                    ]
                }
          description: 'The entity send can not be preocessed, since there are validation errors'
      queryParameters: {}
    '/{app_id}':
      displayName: '{app_id}'
      description: ''
      uriParameters:
        app_id:
          displayName: app_id
          type: string
      get:
        description: 'Get the application with id `app_id`. The response includes some status information besides the current configuration of the app. You can specify optional embed arguments, to get more embedded information.'
        responses:
          '200':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "apps": [
                          {
                              "id": "/myapp",
                              "cmd": "env && sleep 60",
                              "args": null,
                              "user": null,
                              "env": {
                                  "LD_LIBRARY_PATH": "/usr/local/lib/myLib"
                              },
                              "instances": 3,
                              "cpus": 0.1,
                              "mem": 5,
                              "disk": 0,
                              "executor": "",
                              "constraints": [
                                  [
                                      "hostname",
                                      "UNIQUE",
                                      ""
                                  ]
                              ],
                              "uris": [
                                  "https://raw.github.com/mesosphere/marathon/master/README.md"
                              ],
                              "storeUrls": [],
                              "ports": [
                                  10013,
                                  10015
                              ],
                              "requirePorts": false,
                              "backoffSeconds": 1,
                              "backoffFactor": 1.15,
                              "maxLaunchDelaySeconds": 3600,
                              "container": null,
                              "healthChecks": [],
                              "dependencies": [],
                              "upgradeStrategy": {
                                  "minimumHealthCapacity": 1,
                                  "maximumOverCapacity": 1
                              },
                              "labels": {},
                              "acceptedResourceRoles": null,
                              "version": "2015-09-25T15:13:48.343Z",
                              "versionInfo": {
                                  "lastScalingAt": "2015-09-25T15:13:48.343Z",
                                  "lastConfigChangeAt": "2015-09-25T15:13:48.343Z"
                              },
                              "tasksStaged": 0,
                              "tasksRunning": 0,
                              "tasksHealthy": 0,
                              "tasksUnhealthy": 0,
                              "deployments": [
                                  {
                                      "id": "9538079c-3898-4e32-aa31-799bf9097f74"
                                  }
                              ]
                          }
                      ]
                  }
          '401':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid username or password."
                  }
            description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
          '403':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Not Authorized to perform this action!"
                  }
            description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
          '404':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "App '/not_existent' does not exist"
                  }
            description: No task found with this `app_id`.
        queryParameters:
          embed:
            type: string
            description: |-
              Embeds nested resources that match the supplied path. You can specify this parameter multiple times with different values. <br/>
              - <code>app.tasks</code>. embed tasks Note&#58; if this embed is definded, it automatically sets <code>apps.deployments</code> but this will change in a future release. Please define all embeds explicitly.
              - <code>app.counts</code>. embed all task counts (tasksStaged, tasksRunning, tasksHealthy, tasksUnhealthy) <br/> Note&#58; currently embedded by default but this will change in a future release. Please define all embeds explicitly.
              - <code>app.deployments</code>. embed all deployment identifier, if the related app currently is in deployment.
              - <code>app.lastTaskFailure</code> embeds the lastTaskFailure for the application if there is one.
              - <code>app.failures</code> Shorthand for apps.lastTaskFailure, apps.tasks, apps.counts and apps.deployments.<br/> Note&#58; deprecated and will be removed in future versions Please define all embeds explicitly.
              - <code>app.taskStats</code> exposes task statatistics in the JSON.
            enum:
              - app.tasks
              - app.count
              - app.deployments
              - app.lastTaskFailure
              - app.failures
              - app.taskStats
            example: 'embed=app.deployments&embed=app.lastTaskFailure'
            displayName: embed
      put:
        description: |-
          Replaces parameters of a running application. If no application with the given id exists, it will be created. If there is an application with this id, all running instances get upgraded to the new definition.

          Note&#58;  This operation will create a deployment. The operation finishes, if the deployment succeeds. You can query the deployments endoint to see the status of the deployment.
        body:
          application/json:
            example: |-
              {
                  "id": "/foo",
                  "instances": 2,
                  "cmd": "sleep 1000",
                  "cpus": 0.1,
                  "disk": 0,
                  "mem": 16,
                  "acceptedResourceRoles": [
                      "mesos_role"
                  ],
                  "args": [
                      "sleep",
                      "100"
                  ],
                  "backoffFactor": 1.15,
                  "backoffSeconds": 1,
                  "constraints": [
                      [
                          "hostname",
                          "LIKE",
                          "srv2.*"
                      ]
                  ],
                  "container": {
                      "docker": {
                          "forcePullImage": false,
                          "image": "mesosphere:marathon/latest",
                          "network": "BRIDGE",
                          "parameters": [
                              {
                                  "key": "name",
                                  "value": "kdc"
                              }
                          ],
                          "portMappings": [
                              {
                                  "containerPort": 80,
                                  "hostPort": 0,
                                  "protocol": "tcp",
                                  "servicePort": 10019
                              }
                          ],
                          "privileged": false
                      },
                      "type": "DOCKER",
                      "volumes": [
                          {
                              "containerPath": "/docker_storage",
                              "hostPath": "/hdd/tools/docker/registry",
                              "mode": "RW"
                          }
                      ]
                  },
                  "dependencies": [
                      "/prod/group"
                  ],
                  "env": {
                      "XPS1": "Test",
                      "XPS2": "Rest"
                  },
                  "executor": "",
                  "healthChecks": [
                      {
                          "gracePeriodSeconds": 300,
                          "ignoreHttp1xx": false,
                          "intervalSeconds": 20,
                          "maxConsecutiveFailures": 3,
                          "path": "/",
                          "portIndex": 0,
                          "protocol": "HTTP",
                          "timeoutSeconds": 20
                      }
                  ],
                  "labels": {
                      "owner": "zeus",
                      "note": "Away from olympus"
                  },
                  "maxLaunchDelaySeconds": 3600,
                  "ipAddress": {
                      "discovery": {
                          "ports": [
                              {
                                  "number": 8080,
                                  "name": "rest_endpoint",
                                  "protocol": "tcp"
                              }
                          ]
                      },
                      "groups": [
                          "dev"
                      ],
                      "labels": {
                          "environment": "dev"
                      }
                  },
                  "ports": [
                      0
                  ],
                  "requirePorts": false,
                  "upgradeStrategy": {
                      "maximumOverCapacity": 1,
                      "minimumHealthCapacity": 1
                  },
                  "fetch": [
                      {
                          "uri": "https://foo.com/setup.py"
                      },
                      {
                          "uri": "https://foo.com/archive.zip",
                          "executable": false,
                          "extract": true,
                          "cache": true
                      }
                  ],
                  "user": "root"
              }
            schema: "{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"additionalProperties\": false,\n    \"definitions\": {\n        \"pathType\": {\n            \"type\": \"string\",\n            \"pattern\": \"^(\\\\/?((\\\\.{2})|([a-z0-9][a-z0-9\\\\-.]*[a-z0-9]+)|([a-z0-9]*))($|\\\\/))+$\",\n            \"minLength\": 1\n        }\n    },\n    \"not\": {\n        \"allOf\": [\n            {\n                \"required\": [\n                    \"cmd\"\n                ]\n            },\n            {\n                \"required\": [\n                    \"args\"\n                ]\n            }\n        ]\n    },\n    \"properties\": {\n        \"acceptedResourceRoles\": {\n            \"items\": {\n                \"type\": \"string\"\n            },\n            \"type\": \"array\",\n            \"description\": \"Optional. A list of resource roles. Marathon considers only resource offers with roles in this list for launching tasks of this app. If you do not specify this, Marathon considers all resource offers with roles that have been configured by the `--default_accepted_resource_roles` command line flag. If no `--default_accepted_resource_roles` was given on startup, Marathon considers all resource offers. To register Marathon for a role, you need to specify the `--mesos_role` command line flag on startup. If you want to assign all resources of a slave to a role, you can use the `--default_role` argument when starting up the slave. If you need a more fine-grained configuration, you can use the `--resources` argument to specify resource shares per role. The Mesos master needs to be started with `--roles` followed by a comma-separated list of all roles you want to use across your cluster. See [the Mesos command line documentation](http://mesos.apache.org/documentation/latest/configuration/) for details.\"\n        },\n        \"args\": {\n            \"items\": {\n                \"type\": \"string\"\n            },\n            \"type\": \"array\",\n            \"description\": \"An array of strings that represents an alternative mode of specifying the command to run. This was motivated by safe usage of containerizer features like a custom Docker ENTRYPOINT. This args field may be used in place of cmd even when using the default command executor. This change mirrors API and semantics changes in the Mesos CommandInfo protobuf message starting with version `0.20.0`.  Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same app.\"\n        },\n        \"backoffFactor\": {\n            \"minimum\": 1,\n            \"type\": \"number\",\n            \"description\": \"Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.\"\n        },\n        \"backoffSeconds\": {\n            \"description\": \"Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.\",\n            \"minimum\": 0,\n            \"type\": \"integer\"\n        },\n        \"cmd\": {\n            \"description\": \"The command that is executed.  This value is wrapped by Mesos via `/bin/sh -c ${app.cmd}`.  Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same app.\",\n            \"type\": \"string\",\n            \"minLength\": 1\n        },\n        \"constraints\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"array\",\n                \"items\": [\n                    {\n                        \"type\": \"string\"\n                    },\n                    {\n                        \"type\": \"string\",\n                        \"enum\": [\n                            \"UNIQUE\",\n                            \"CLUSTER\",\n                            \"GROUP_BY\",\n                            \"LIKE\",\n                            \"UNLIKE\"\n                        ]\n                    },\n                    {\n                        \"type\": \"string\"\n                    }\n                ],\n                \"minItems\": 2,\n                \"additionalItems\": false\n            },\n            \"description\": \"Valid constraint operators are one of UNIQUE, CLUSTER, GROUP_BY, LIKE, UNLIKE.\"\n        },\n        \"container\": {\n            \"additionalProperties\": false,\n            \"properties\": {\n                \"docker\": {\n                    \"additionalProperties\": false,\n                    \"properties\": {\n                        \"forcePullImage\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"The container will be pulled, regardless if it is already available on the local system.\"\n                        },\n                        \"image\": {\n                            \"type\": \"string\",\n                            \"minLength\": 1,\n                            \"description\": \"The name of the docker image to use.\"\n                        },\n                        \"network\": {\n                            \"type\": \"string\",\n                            \"description\": \"The networking mode, this container should operate in. One of BRIDGED|HOST|NONE\",\n                            \"enum\": [\n                                \"BRIDGE\",\n                                \"HOST\",\n                                \"NONE\"\n                            ]\n                        },\n                        \"parameters\": {\n                            \"type\": \"array\",\n                            \"description\": \"Allowing arbitrary parameters to be passed to docker CLI. Note that anything passed to this field is not guaranteed to be supported moving forward, as we might move away from the docker CLI.\",\n                            \"items\": {\n                                \"type\": \"object\",\n                                \"additionalProperties\": false,\n                                \"properties\": {\n                                    \"key\": {\n                                        \"type\": \"string\",\n                                        \"minLength\": 1,\n                                        \"description\": \"Key of this parameter\"\n                                    },\n                                    \"value\": {\n                                        \"type\": \"string\",\n                                        \"description\": \"Value of this parameter\"\n                                    }\n                                },\n                                \"required\": [\n                                    \"key\",\n                                    \"value\"\n                                ]\n                            }\n                        },\n                        \"portMappings\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"object\",\n                                \"additionalProperties\": false,\n                                \"properties\": {\n                                    \"containerPort\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Refers to the port the application listens to inside of the container. It is optional and now defaults to 0, in which case Marathon assigns the container port the same value as the assigned hostPort. This is especially useful for apps that advertise the port they are listening on to the outside world for P2P communication. Without containerPort: 0 they would erroneously advertise their private container port which is usually not the same as the externally visible host port.\",\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0\n                                    },\n                                    \"hostPort\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Retains the traditional meaning in Marathon, which is a random port from the range included in the Mesos resource offer. The resulting host ports for each task are exposed via the task details in the REST API and the Marathon web UI. hostPort is optional and defaults to 0.\",\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0\n                                    },\n                                    \"protocol\": {\n                                        \"type\": \"string\",\n                                        \"description\": \"parameter is optional and defaults to tcp.\"\n                                    },\n                                    \"servicePort\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Is a helper port intended for doing service discovery using a well-known port per service. The assigned servicePort value is not used/interpreted by Marathon itself but supposed to used by load balancer infrastructure. See Service Discovery Load Balancing doc page. The servicePort parameter is optional and defaults to 0. Like hostPort, If the value is 0, a random port will be assigned. If a servicePort value is assigned by Marathon then Marathon guarantees that its value is unique across the cluster. The values for random service ports are in the range [local_port_min, local_port_max] where local_port_min and local_port_max are command line options with default values of 10000 and 20000, respectively.\",\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0\n                                    }\n                                }\n                            }\n                        },\n                        \"privileged\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Run this docker image in privileged mode.\"\n                        }\n                    },\n                    \"required\": [\n                        \"image\"\n                    ],\n                    \"type\": \"object\"\n                },\n                \"type\": {\n                    \"type\": \"string\",\n                    \"description\": \"Supported container types at the moment are DOCKER and MESOS.\",\n                    \"enum\": [\n                        \"MESOS\",\n                        \"DOCKER\"\n                    ]\n                },\n                \"volumes\": {\n                    \"items\": {\n                        \"additionalProperties\": false,\n                        \"properties\": {\n                            \"containerPath\": {\n                                \"type\": \"string\",\n                                \"description\": \"The path of the volume in the container\",\n                                \"minLength\": 1\n                            },\n                            \"hostPath\": {\n                                \"type\": \"string\",\n                                \"description\": \"The path of the volume on the host\",\n                                \"minLength\": 1\n                            },\n                            \"persistent\": {\n                                \"additionalProperties\": false,\n                                \"properties\": {\n                                    \"size\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"The size of the persistent volume in MiB\",\n                                        \"minimum\": 0\n                                    }\n                                },\n                                \"type\": \"object\"\n                            },\n                            \"mode\": {\n                                \"type\": \"string\",\n                                \"description\": \"Possible values are RO for ReadOnly and RW for Read/Write\",\n                                \"enum\": [\n                                    \"RO\",\n                                    \"RW\"\n                                ]\n                            }\n                        },\n                        \"type\": \"object\"\n                    },\n                    \"type\": \"array\"\n                }\n            },\n            \"type\": \"object\"\n        },\n        \"cpus\": {\n            \"type\": \"number\",\n            \"description\": \"The number of CPU shares this application needs per instance. This number does not have to be integer, but can be a fraction.\",\n            \"minimum\": 0\n        },\n        \"dependencies\": {\n            \"type\": \"array\",\n            \"description\": \"A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.\",\n            \"items\": {\n                \"$ref\": \"#/definitions/pathType\"\n            }\n        },\n        \"disk\": {\n            \"type\": \"number\",\n            \"description\": \"How much disk space is needed for this application. This number does not have to be an integer, but can be a fraction.\",\n            \"minimum\": 0\n        },\n        \"env\": {\n            \"patternProperties\": {\n                \".*\": {\n                    \"type\": \"string\"\n                }\n            },\n            \"type\": \"object\"\n        },\n        \"executor\": {\n            \"type\": \"string\",\n            \"description\": \"The executor to use to launch this application. Different executors are available. The simplest one (and the default if none is given) is //cmd, which takes the cmd and executes that on the shell level.\",\n            \"pattern\": \"^(|\\\\/\\\\/cmd|\\\\/?[^\\\\/]+(\\\\/[^\\\\/]+)*)$\"\n        },\n        \"fetch\": {\n            \"type\": \"array\",\n            \"description\": \"Provided URIs are passed to Mesos fetcher module and resolved in runtime.\",\n            \"items\": {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"properties\": {\n                    \"uri\": {\n                        \"type\": \"string\",\n                        \"description\": \"URI to be fetched by Mesos fetcher module\"\n                    },\n                    \"executable\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Set fetched artifact as executable\"\n                    },\n                    \"extract\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Extract fetched artifact if supported by Mesos fetcher module\"\n                    },\n                    \"cache\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Cache fetched artifact if supported by Mesos fetcher module\"\n                    }\n                },\n                \"required\": [\n                    \"uri\"\n                ]\n            }\n        },\n        \"healthChecks\": {\n            \"items\": {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"properties\": {\n                    \"command\": {\n                        \"type\": \"object\",\n                        \"items\": {\n                            \"additionalProperties\": false,\n                            \"properties\": {\n                                \"value\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"The health check command to execute.\"\n                                }\n                            }\n                        }\n                    },\n                    \"gracePeriodSeconds\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Health check failures are ignored within this number of seconds of the task being started or until the task becomes healthy for the first time.\",\n                        \"minimum\": 0\n                    },\n                    \"ignoreHttp1xx\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Ignore HTTP 1xx responses.\"\n                    },\n                    \"intervalSeconds\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Number of seconds to wait between health checks.\",\n                        \"minimum\": 0\n                    },\n                    \"maxConsecutiveFailures\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Number of consecutive health check failures after which the unhealthy task should be killed.\",\n                        \"minimum\": 0\n                    },\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"Path to endpoint exposed by the task that will provide health status. Example: /path/to/health. Note: only used if protocol == HTTP[S].\"\n                    },\n                    \"port\": {\n                        \"type\": \"integer\",\n                        \"description\": \"The specific port to connect to. In case of dynamic ports, see portIndex.\",\n                        \"maximum\": 65535,\n                        \"minimum\": 0\n                    },\n                    \"portIndex\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Index in this app's ports array to be used for health requests. An index is used so the app can use random ports, like [0, 0, 0] for example, and tasks could be started with port environment variables like $PORT1.\",\n                        \"minimum\": 0\n                    },\n                    \"protocol\": {\n                        \"type\": \"string\",\n                        \"description\": \"Protocol of the requests to be performed. One of HTTP, HTTPS, TCP or COMMAND.\",\n                        \"enum\": [\n                            \"HTTP\",\n                            \"HTTPS\",\n                            \"TCP\",\n                            \"COMMAND\"\n                        ]\n                    },\n                    \"timeoutSeconds\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Number of seconds after which a health check is considered a failure regardless of the response.\",\n                        \"minimum\": 0\n                    }\n                }\n            },\n            \"type\": \"array\"\n        },\n        \"id\": {\n            \"$ref\": \"#/definitions/pathType\",\n            \"description\": \"Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.\"\n        },\n        \"instances\": {\n            \"type\": \"integer\",\n            \"description\": \"The number of instances of this application to start. Please note: this number can be changed any time as needed to scale the application.\",\n            \"minimum\": 0\n        },\n        \"labels\": {\n            \"type\": \"object\",\n            \"description\": \"Attaching metadata to apps can be useful to expose additional information to other services, so we added the ability to place labels on apps (for example, you could label apps staging and production to mark services by their position in the pipeline).\",\n            \"additionalProperties\": {\n                \"type\": \"string\"\n            }\n        },\n        \"maxLaunchDelaySeconds\": {\n            \"type\": \"integer\",\n            \"description\": \"Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.\",\n            \"minimum\": 0\n        },\n        \"mem\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of memory in MB that is needed for the application per instance.\",\n            \"minimum\": 0\n        },\n        \"ipAddress\": {\n            \"type\": \"object\",\n            \"description\": \"If an application definition includes the 'ipAddress' field, then Marathon will request a per-task IP from Mesos. A separate ports/portMappings configuration is then disallowed.\",\n            \"properties\": {\n                \"discovery\": {\n                    \"type\": \"object\",\n                    \"description\": \"Information useful for service discovery.\",\n                    \"properties\": {\n                        \"ports\": {\n                            \"type\": \"array\",\n                            \"description\": \"Array of objects describing the ports exposed by each task.\",\n                            \"items\": {\n                                \"type\": \"object\",\n                                \"description\": \"Port\",\n                                \"properties\": {\n                                    \"number\": {\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0,\n                                        \"type\": \"integer\",\n                                        \"description\": \"The port number.\"\n                                    },\n                                    \"name\": {\n                                        \"type\": \"string\",\n                                        \"description\": \"Name of the port.\",\n                                        \"pattern\": \"^[a-z][a-z0-9-]*$\"\n                                    },\n                                    \"protocol\": {\n                                        \"enum\": [\n                                            \"tcp\",\n                                            \"udp\"\n                                        ],\n                                        \"description\": \"Protocol of the port (one of ['tcp', 'udp']).\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n                \"groups\": {\n                    \"type\": \"array\",\n                    \"description\": \"Array of network groups. One IP address can belong to zero or more network groups. The idea is that containers can only reach containers with which they share at least one network group.\",\n                    \"items\": {\n                        \"type\": \"string\",\n                        \"description\": \"The name of the network group.\"\n                    }\n                },\n                \"labels\": {\n                    \"type\": \"object\",\n                    \"description\": \"Key value pair for meta data on that network interface.\",\n                    \"properties\": {},\n                    \"additionalProperties\": true\n                }\n            }\n        },\n        \"ports\": {\n            \"type\": \"array\",\n            \"description\": \"An array of required port resources on the agent host. The number of items in the array determines how many dynamic ports are allocated for every task. For every port that is zero, a globally unique (cluster-wide) port is assigned and provided as part of the app definition to be used in load balancing definitions.\",\n            \"items\": {\n                \"maximum\": 65535,\n                \"minimum\": 0,\n                \"type\": \"integer\"\n            }\n        },\n        \"residency\": {\n            \"type\": \"object\",\n            \"description\": \"When using local persistent volumes that pin tasks onto agents, these values define how Marathon handles terminal states of these tasks.\",\n            \"properties\": {\n                \"relaunchEscalationTimeoutSeconds\": {\n                    \"type\": \"integer\",\n                    \"description\": \"When a task using persistent local volumes cannot be restarted on the agent it's been pinned to, Marathon will try to launch this task on another node after this timeout. Defaults to 3600 (one hour).\",\n                    \"minimum\": 0,\n                    \"additionalProperties\": false\n                },\n                \"taskLostBehavior\": {\n                    \"type\": \"string\",\n                    \"description\": \"When Marathon receives a TASK_LOST status update indicating that the agent running the task is gone, this property defines whether Marathon will launch the task on another node or not. Defaults to WAIT_FOREVER\",\n                    \"enum\": [\n                        \"WAIT_FOREVER\",\n                        \"RELAUNCH_AFTER_TIMEOUT\"\n                    ],\n                    \"additionalProperties\": false\n                }\n            },\n            \"additionalProperties\": false\n        },\n        \"requirePorts\": {\n            \"type\": \"boolean\",\n            \"description\": \"Normally, the host ports of your tasks are automatically assigned. This corresponds to the requirePorts value false which is the default. If you need more control and want to specify your host ports in advance, you can set requirePorts to true. This way the ports you have specified are used as host ports. That also means that Marathon can schedule the associated tasks only on hosts that have the specified ports available.\"\n        },\n        \"storeUrls\": {\n            \"type\": \"array\",\n            \"description\": \"URL's that have to be resolved and put into the artifact store, before the task will be started.\",\n            \"items\": {\n                \"type\": \"string\",\n                \"minLength\": 1\n            }\n        },\n        \"upgradeStrategy\": {\n            \"type\": \"object\",\n            \"description\": \"During an upgrade all instances of an application get replaced by a new version. The upgradeStrategy controls how Marathon stops old versions and launches new versions.\",\n            \"additionalProperties\": false,\n            \"properties\": {\n                \"maximumOverCapacity\": {\n                    \"type\": \"number\",\n                    \"description\": \"A number between 0 and 1 which is multiplied with the instance count. This is the maximum number of additional instances launched at any point of time during the upgrade process.\",\n                    \"maximum\": 1,\n                    \"minimum\": 0\n                },\n                \"minimumHealthCapacity\": {\n                    \"type\": \"number\",\n                    \"description\": \"A number between 0 and 1 that is multiplied with the instance count. This is the minimum number of healthy nodes that do not sacrifice overall application purpose. Marathon will make sure, during the upgrade process, that at any point of time this number of healthy instances are up.\",\n                    \"maximum\": 1,\n                    \"minimum\": 0\n                }\n            }\n        },\n        \"uris\": {\n            \"type\": \"array\",\n            \"description\": \"URIs defined here are resolved, before the application gets started. If the application has external dependencies, they should be defined here.\",\n            \"items\": {\n                \"type\": \"string\",\n                \"minLength\": 1\n            }\n        },\n        \"user\": {\n            \"type\": \"string\",\n            \"description\": \"The user to use to run the tasks on the agent.\"\n        },\n        \"version\": {\n            \"type\": \"string\",\n            \"description\": \"The version of this definition.\",\n            \"format\": \"date-time\"\n        },\n        \"versionInfo\": {\n            \"type\": \"object\",\n            \"description\": \"Detailed version information.\",\n            \"additionalProperties\": false,\n            \"properties\": {\n                \"lastScalingAt\": {\n                    \"type\": \"string\",\n                    \"description\": \"Contains the time stamp of the last change to this app which was not simply a scaling or a restarting configuration.\",\n                    \"format\": \"date-time\"\n                },\n                \"lastConfigChangeAt\": {\n                    \"type\": \"string\",\n                    \"description\": \"Contains the time stamp of the last change including changes like scaling or restarting the app. Since our versions are time based, this is currently equal to version.\",\n                    \"format\": \"date-time\"\n                }\n            }\n        }\n    },\n    \"required\": [\n        \"id\"\n    ],\n    \"type\": \"object\"\n}"
        responses:
          '200':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "deploymentId": "5ed4c0c5-9ff8-4a6f-a0cd-f57f59a34b43",
                      "version": "2015-09-29T15:59:51.164Z"
                  }
            description: 'A deployment is started which has a unique deployment identifier. The related deployment can be fetched from the /v2/deployments endpoint. If the deployement is gone from the list of deployments, than this means it is finished. As long as the deployment runs, the effect of that change operation is visible only partially.'
          '400':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid JSON",
                      "details": [
                          {
                              "path": "/id",
                              "errors": [
                                  "error.expected.jsstring"
                              ]
                          }
                      ]
                  }
            description: The application definition provided in the body is not valid.
          '401':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid username or password."
                  }
            description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
          '403':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Not Authorized to perform this action!"
                  }
            description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
          '404':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "App '/not_existent' does not exist"
                  }
            description: No task found with this `app_id`.
          '409':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "App is locked by one or more deployments. Override with the option '?force=true'. View details at '/v2/deployments/<DEPLOYMENT_ID>'.",
                      "deployments": [
                          {
                              "id": "97c136bf-5a28-4821-9d94-480d9fbb01c8"
                          }
                      ]
                  }
            description: 'There is an already running deployment, that affects this application. To override this deployment, use the force=true flag'
          '422':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Object is not valid",
                      "details": [
                          {
                              "attribute": "upgradeStrategy.minimumHealthCapacity",
                              "error": "is greater than 1"
                          }
                      ]
                  }
            description: 'The entity send can not be preocessed, since there are validation errors'
        queryParameters:
          force:
            type: boolean
            description: |-
              Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
              Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
            required: false
            displayName: force
      delete:
        description: |-
          Destroy an application. All data about that application will be deleted.
          Note&#58;  This operation will create a deployment. The operation finishes, if the deployment succeeds. You can query the deployments endoint to see the status of the deployment.
        responses:
          '200':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "deploymentId": "5ed4c0c5-9ff8-4a6f-a0cd-f57f59a34b43",
                      "version": "2015-09-29T15:59:51.164Z"
                  }
            description: 'A deployment is started which has a unique deployment identifier. The related deployment can be fetched from the /v2/deployments endpoint. If the deployement is gone from the list of deployments, than this means it is finished. As long as the deployment runs, the effect of that change operation is visible only partially.'
          '401':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid username or password."
                  }
            description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
          '403':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Not Authorized to perform this action!"
                  }
            description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
          '404':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "App '/not-existing' does not exist"
                  }
            description: No app with this id known.
          '409':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "App is locked by one or more deployments. Override with the option '?force=true'. View details at '/v2/deployments/<DEPLOYMENT_ID>'.",
                      "deployments": [
                          {
                              "id": "97c136bf-5a28-4821-9d94-480d9fbb01c8"
                          }
                      ]
                  }
            description: 'There is an already running deployment, that affects this application. To override this deployment, use the force=true flag'
        queryParameters:
          force:
            type: boolean
            description: |-
              Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
              Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
            required: false
            displayName: force
      /restart:
        displayName: restart
        description: ''
        uriParameters: {}
        post:
          description: Restart all tasks of this application.
          body: {}
          responses:
            '200':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "deploymentId": "5ed4c0c5-9ff8-4a6f-a0cd-f57f59a34b43",
                        "version": "2015-09-29T15:59:51.164Z"
                    }
              description: 'A deployment is started which has a unique deployment identifier. The related deployment can be fetched from the /v2/deployments endpoint. If the deployement is gone from the list of deployments, than this means it is finished. As long as the deployment runs, the effect of that change operation is visible only partially.'
            '401':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "Invalid username or password."
                    }
              description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
            '403':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "Not Authorized to perform this action!"
                    }
              description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
            '404':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "App '/not_existent' does not exist"
                    }
              description: No task found with this `app_id`.
            '409':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "App is locked by one or more deployments. Override with the option '?force=true'. View details at '/v2/deployments/<DEPLOYMENT_ID>'.",
                        "deployments": [
                            {
                                "id": "97c136bf-5a28-4821-9d94-480d9fbb01c8"
                            }
                        ]
                    }
              description: 'There is an already running deployment, that affects this application. To override this deployment, use the force=true flag'
          queryParameters:
            force:
              type: boolean
              description: |-
                Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
                Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
              required: false
              displayName: force
      /tasks:
        displayName: tasks
        description: ''
        uriParameters: {}
        get:
          description: List all running tasks for application `app_id`.
          responses:
            '200':
              body:
                text/plain:
                  schema: '{}'
                  example: "minecraft_survival-world\t10013\tsrv7.hw.ca1.mesosphere.com:31756\n"
              description: The list of running tasks for application `app_id`.
            '401':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "Invalid username or password."
                    }
              description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
            '403':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "Not Authorized to perform this action!"
                    }
              description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
            '404':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "App '/not_existent' does not exist"
                    }
              description: No task found with this `app_id`.
          queryParameters: {}
        delete:
          description: Kill tasks that belong to the application `app_id`
          responses:
            '200':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "tasks": [
                            {
                                "appId": "/minecraft/survival-world",
                                "host": "srv7.hw.ca1.mesosphere.com",
                                "id": "minecraft_survival-world.564bd685-4c30-11e5-98c1-be5b2935a987",
                                "ports": [
                                    31756
                                ],
                                "slaveId": null,
                                "stagedAt": "2015-08-26T20:23:39.463Z",
                                "startedAt": "2015-08-26T20:23:44.678Z",
                                "version": "2015-04-17T04:00:14.171Z"
                            }
                        ]
                    }
              description: 'If scale=false, all tasks that were killed are returned. If scale=true, than a deployment is triggered and the deployment is returned.'
            '401':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "Invalid username or password."
                    }
              description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
            '403':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "Not Authorized to perform this action!"
                    }
              description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
            '404':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "App '/not_existent' does not exist"
                    }
              description: No task found with this `app_id`.
            '409':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "App is locked by one or more deployments. Override with the option '?force=true'. View details at '/v2/deployments/<DEPLOYMENT_ID>'.",
                        "deployments": [
                            {
                                "id": "97c136bf-5a28-4821-9d94-480d9fbb01c8"
                            }
                        ]
                    }
              description: 'There is an already running deployment, that affects this application. To override this deployment, use the force=true flag'
          queryParameters:
            force:
              type: boolean
              description: |-
                Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
                Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
              required: false
              displayName: force
            host:
              type: string
              description: all tasks of that application on the supplied slave are killed
              displayName: host
            scale:
              type: boolean
              description: 'If `scale=true` is specified, then the application is scaled down by the number of killed tasks.'
              displayName: scale
        '/{task_id}':
          displayName: '{task_id}'
          description: ''
          uriParameters:
            task_id:
              displayName: task_id
              type: string
          delete:
            description: Kill the task with ID `task_id` that belongs to the application `app_id`.
            responses:
              '200':
                body:
                  application/json:
                    schema: '{}'
                    example: |-
                      {
                          "task": [
                              {
                                  "appId": "/minecraft/survival-world",
                                  "host": "srv7.hw.ca1.mesosphere.com",
                                  "id": "minecraft_survival-world.564bd685-4c30-11e5-98c1-be5b2935a987",
                                  "ports": [
                                      31756
                                  ],
                                  "slaveId": null,
                                  "stagedAt": "2015-08-26T20:23:39.463Z",
                                  "startedAt": "2015-08-26T20:23:44.678Z",
                                  "version": "2015-04-17T04:00:14.171Z"
                              }
                          ]
                      }
                description: 'If scale=false, the task that was killed is returned. If scale=true, than a deployment is triggered and the deployment is returned.'
              '401':
                body:
                  application/json:
                    schema: '{}'
                    example: |-
                      {
                          "message": "Invalid username or password."
                      }
                description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
              '403':
                body:
                  application/json:
                    schema: '{}'
                    example: |-
                      {
                          "message": "Not Authorized to perform this action!"
                      }
                description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
              '404':
                body:
                  application/json:
                    schema: '{}'
                    example: |-
                      {
                          "message": "Task 'not-existing' does not exist"
                      }
                description: No task found with this task_id.
              '409':
                body:
                  application/json:
                    schema: '{}'
                    example: |-
                      {
                          "message": "App is locked by one or more deployments. Override with the option '?force=true'. View details at '/v2/deployments/<DEPLOYMENT_ID>'.",
                          "deployments": [
                              {
                                  "id": "97c136bf-5a28-4821-9d94-480d9fbb01c8"
                              }
                          ]
                      }
                description: 'There is an already running deployment, that affects this application. To override this deployment, use the force=true flag'
            queryParameters:
              force:
                type: boolean
                description: |-
                  Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
                  Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
                required: false
                displayName: force
              scale:
                type: boolean
                description: 'If `scale=true` is specified, then the application is scaled down by the number of killed tasks.'
                displayName: scale
      /versions:
        displayName: versions
        description: ''
        uriParameters: {}
        get:
          description: List the versions of the application with id `app_id`
          responses:
            '200':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "versions": [
                            "2014-03-01T23:42:20.938Z"
                        ]
                    }
              description: The list of versions of the application
            '401':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "Invalid username or password."
                    }
              description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
            '403':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "Not Authorized to perform this action!"
                    }
              description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
            '404':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "App '/not_existent' does not exist"
                    }
              description: No task found with this `app_id`.
          queryParameters: {}
        '/{version}':
          displayName: '{version}'
          description: ''
          uriParameters:
            version:
              displayName: version
              type: string
          get:
            description: List the configuration of the application with id `app_id` at version `version`.
            responses:
              '200':
                body:
                  application/json:
                    schema: '{}'
                    example: |-
                      {
                          "id": "/foo",
                          "instances": 2,
                          "cmd": "sleep 1000",
                          "cpus": 0.1,
                          "disk": 0,
                          "mem": 16,
                          "acceptedResourceRoles": [
                              "mesos_role"
                          ],
                          "args": [
                              "sleep",
                              "100"
                          ],
                          "backoffFactor": 1.15,
                          "backoffSeconds": 1,
                          "constraints": [
                              [
                                  "hostname",
                                  "LIKE",
                                  "srv2.*"
                              ]
                          ],
                          "container": {
                              "docker": {
                                  "forcePullImage": false,
                                  "image": "mesosphere:marathon/latest",
                                  "network": "BRIDGE",
                                  "parameters": [
                                      {
                                          "key": "name",
                                          "value": "kdc"
                                      }
                                  ],
                                  "portMappings": [
                                      {
                                          "containerPort": 80,
                                          "hostPort": 0,
                                          "protocol": "tcp",
                                          "servicePort": 10019
                                      }
                                  ],
                                  "privileged": false
                              },
                              "type": "DOCKER",
                              "volumes": [
                                  {
                                      "containerPath": "/docker_storage",
                                      "hostPath": "/hdd/tools/docker/registry",
                                      "mode": "RW"
                                  }
                              ]
                          },
                          "dependencies": [
                              "/prod/group"
                          ],
                          "env": {
                              "XPS1": "Test",
                              "XPS2": "Rest"
                          },
                          "executor": "",
                          "healthChecks": [
                              {
                                  "gracePeriodSeconds": 300,
                                  "ignoreHttp1xx": false,
                                  "intervalSeconds": 20,
                                  "maxConsecutiveFailures": 3,
                                  "path": "/",
                                  "portIndex": 0,
                                  "protocol": "HTTP",
                                  "timeoutSeconds": 20
                              }
                          ],
                          "labels": {
                              "owner": "zeus",
                              "note": "Away from olympus"
                          },
                          "maxLaunchDelaySeconds": 3600,
                          "ipAddress": {
                              "discovery": {
                                  "ports": [
                                      {
                                          "number": 8080,
                                          "name": "rest_endpoint",
                                          "protocol": "tcp"
                                      }
                                  ]
                              },
                              "groups": [
                                  "dev"
                              ],
                              "labels": {
                                  "environment": "dev"
                              }
                          },
                          "ports": [
                              0
                          ],
                          "requirePorts": false,
                          "upgradeStrategy": {
                              "maximumOverCapacity": 1,
                              "minimumHealthCapacity": 1
                          },
                          "fetch": [
                              {
                                  "uri": "https://foo.com/setup.py"
                              },
                              {
                                  "uri": "https://foo.com/archive.zip",
                                  "executable": false,
                                  "extract": true,
                                  "cache": true
                              }
                          ],
                          "user": "root"
                      }
                description: The application definition at that point in time.
              '401':
                body:
                  application/json:
                    schema: '{}'
                    example: |-
                      {
                          "message": "Invalid username or password."
                      }
                description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
              '403':
                body:
                  application/json:
                    schema: '{}'
                    example: |-
                      {
                          "message": "Not Authorized to perform this action!"
                      }
                description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
              '404':
                body:
                  application/json:
                    schema: '{}'
                    example: |-
                      {
                          "message": "App '/not_existent' does not exist"
                      }
                description: No task found with this `app_id`.
            queryParameters: {}
  /deployments:
    displayName: deployments
    description: ''
    uriParameters: {}
    get:
      description: |-
        List all running deployments. A deployment is a change in the service setup.
        A deployment is identified by an id, affects a set of applications and is composed of deployment steps.
        Every step contains a list of actions with following types
        * <code>StartApplication</code> starts an application, which is currently not running.
        * <code>StopApplication</code> stops an already running application.
        * <code>ScaleApplication</code> changes the number of instances of an application and allows to kill specified instances while scaling.
        * <code>RestartApplication</code> upgrades an already deployed application with a new version.
        * <code>ResolveArtifacts</code> Resolve all artifacts of an application
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                [
                    {
                        "id": "97c136bf-5a28-4821-9d94-480d9fbb01c8",
                        "version": "2015-09-30T09:09:17.614Z",
                        "affectedApps": [
                            "/foo"
                        ],
                        "steps": [
                            [
                                {
                                    "action": "StartApplication",
                                    "app": "/foo"
                                }
                            ],
                            [
                                {
                                    "action": "ScaleApplication",
                                    "app": "/foo"
                                }
                            ]
                        ],
                        "currentActions": [
                            {
                                "action": "ScaleApplication",
                                "app": "/foo"
                            }
                        ],
                        "currentStep": 2,
                        "totalSteps": 2
                    }
                ]
          description: The list of all running deployments.
        '401':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid username or password."
                }
          description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
        '403':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Not Authorized to perform this action!"
                }
          description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
      queryParameters: {}
    '/{deployment_id}':
      displayName: '{deployment_id}'
      description: ''
      uriParameters:
        deployment_id:
          displayName: deployment_id
          type: string
      delete:
        description: Revert the deployment with `deployment_id` by creating a new deployment which reverses all changes.
        responses:
          '200':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "deploymentId": "5ed4c0c5-9ff8-4a6f-a0cd-f57f59a34b43",
                      "version": "2015-09-29T15:59:51.164Z"
                  }
            description: 'A deployment is started which has a unique deployment identifier. The related deployment can be fetched from the /v2/deployments endpoint. If the deployement is gone from the list of deployments, than this means it is finished. As long as the deployment runs, the effect of that change operation is visible only partially.'
          '401':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid username or password."
                  }
            description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
          '403':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Not Authorized to perform this action!"
                  }
            description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
          '404':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "DeploymentPlan unknown_deployment does not exist"
                  }
            description: The deployment plan with the given id can not be found.
        queryParameters:
          force:
            type: boolean
            description: 'If set to <code>false</code> (the default) then the deployment is canceled and a new deployment is created to revert the changes of this deployment. Without concurrent deployments, this restores the configuration before this deployment. If set to <code>true</code>, then the deployment is still canceled but no rollback deployment is created.'
            displayName: force
  /groups:
    displayName: groups
    description: ''
    uriParameters: {}
    get:
      description: Get the group with all applications and all transitive child groups.
      responses:
        '200':
          body:
            application/json:
              schema: "{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"id\": \"https://raw.githubusercontent.com/mesosphere/marathon/master/docs/docs/rest-api/public/api/v2/schema/Group.json\",\n    \"additionalProperties\": false,\n    \"definitions\": {\n        \"pathType\": {\n            \"type\": \"string\",\n            \"pattern\": \"^(\\\\/?((\\\\.{2})|([a-z0-9][a-z0-9\\\\-.]*[a-z0-9]+)|([a-z0-9]*))($|\\\\/))+$\",\n            \"minLength\": 1\n        }\n    },\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"$ref\": \"#/definitions/pathType\",\n            \"description\": \"Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.\"\n        },\n        \"apps\": {\n            \"type\": \"array\",\n            \"description\": \"The list of AppDefinitions in this group. See AppDefinition.json for the schema.\",\n            \"items\": {\n                \"$ref\": \"./AppDefinition.json\"\n            }\n        },\n        \"groups\": {\n            \"type\": \"array\",\n            \"description\": \"Groups can build a tree. Each group can contain sub-groups. The sub-groups are defined here.\",\n            \"items\": {\n                \"$ref\": \"#\"\n            }\n        },\n        \"dependencies\": {\n            \"type\": \"array\",\n            \"description\": \"A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.\",\n            \"items\": {\n                \"$ref\": \"#/definitions/pathType\"\n            }\n        },\n        \"version\": {\n            \"type\": \"string\",\n            \"description\": \"The version of this definition.\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"required\": [\n        \"id\"\n    ]\n}"
              example: |-
                {
                    "id": "/",
                    "apps": [],
                    "groups": [
                        {
                            "id": "/tools",
                            "apps": [
                                {
                                    "id": "/tools/oauth-server",
                                    "instances": 2,
                                    "cpus": 1,
                                    "mem": 1024,
                                    "disk": 0,
                                    "constraints": [
                                        [
                                            "hostname",
                                            "UNIQUE"
                                        ]
                                    ],
                                    "uris": [],
                                    "storeUrls": [],
                                    "ports": [
                                        1980
                                    ],
                                    "requirePorts": false,
                                    "backoffSeconds": 1,
                                    "backoffFactor": 1.15,
                                    "maxLaunchDelaySeconds": 3600,
                                    "container": {
                                        "type": "DOCKER",
                                        "volumes": [],
                                        "docker": {
                                            "image": "docker-registry/oauth_server:6d7d463cb8b1517002080a81cf23f9cf7b7fc774",
                                            "network": "HOST",
                                            "privileged": false,
                                            "parameters": [],
                                            "forcePullImage": false
                                        }
                                    },
                                    "healthChecks": [
                                        {
                                            "path": "/",
                                            "protocol": "HTTP",
                                            "portIndex": 0,
                                            "gracePeriodSeconds": 300,
                                            "intervalSeconds": 20,
                                            "timeoutSeconds": 20,
                                            "maxConsecutiveFailures": 3,
                                            "ignoreHttp1xx": false
                                        }
                                    ],
                                    "dependencies": [],
                                    "upgradeStrategy": {
                                        "minimumHealthCapacity": 0.5,
                                        "maximumOverCapacity": 0
                                    },
                                    "version": "2015-09-28T19:47:37.681Z",
                                    "versionInfo": {
                                        "lastScalingAt": "2015-09-28T19:47:37.681Z",
                                        "lastConfigChangeAt": "2015-09-28T19:47:37.681Z"
                                    }
                                },
                                {
                                    "id": "/tools/datadog-agent",
                                    "instances": 5,
                                    "cpus": 1,
                                    "mem": 512,
                                    "disk": 0,
                                    "executor": "",
                                    "constraints": [
                                        [
                                            "hostname",
                                            "UNIQUE"
                                        ]
                                    ],
                                    "uris": [],
                                    "storeUrls": [],
                                    "ports": [
                                        10018
                                    ],
                                    "requirePorts": false,
                                    "backoffSeconds": 1,
                                    "backoffFactor": 1.15,
                                    "maxLaunchDelaySeconds": 3600,
                                    "container": {
                                        "type": "DOCKER",
                                        "volumes": [
                                            {
                                                "containerPath": "/var/run/docker.sock",
                                                "hostPath": "/var/run/docker.sock",
                                                "mode": "RW"
                                            },
                                            {
                                                "containerPath": "/host/proc/mounts",
                                                "hostPath": "/proc/mounts",
                                                "mode": "RO"
                                            },
                                            {
                                                "containerPath": "/host/sys/fs/cgroup",
                                                "hostPath": "/sys/fs/cgroup/",
                                                "mode": "RO"
                                            }
                                        ],
                                        "docker": {
                                            "image": "datadog/docker-dd-agent:latest",
                                            "network": "HOST",
                                            "privileged": true,
                                            "parameters": [],
                                            "forcePullImage": false
                                        }
                                    },
                                    "healthChecks": [],
                                    "dependencies": [],
                                    "upgradeStrategy": {
                                        "minimumHealthCapacity": 0.5,
                                        "maximumOverCapacity": 0
                                    },
                                    "version": "2015-08-26T22:33:24.225Z",
                                    "versionInfo": {
                                        "lastScalingAt": "2015-08-26T22:33:24.225Z",
                                        "lastConfigChangeAt": "2015-05-19T13:59:18.899Z"
                                    }
                                }
                            ],
                            "groups": [
                                {
                                    "id": "/tools/log",
                                    "apps": [],
                                    "groups": [],
                                    "dependencies": [],
                                    "version": "2015-09-17T10:38:20.875Z"
                                },
                                {
                                    "id": "/tools/docker",
                                    "apps": [
                                        {
                                            "id": "/tools/docker/registry",
                                            "instances": 1,
                                            "cpus": 0.5,
                                            "mem": 4096,
                                            "disk": 0,
                                            "executor": "",
                                            "constraints": [],
                                            "uris": [],
                                            "storeUrls": [],
                                            "ports": [
                                                5000
                                            ],
                                            "requirePorts": false,
                                            "backoffSeconds": 1,
                                            "backoffFactor": 1.15,
                                            "maxLaunchDelaySeconds": 3600,
                                            "container": {
                                                "type": "DOCKER",
                                                "volumes": [
                                                    {
                                                        "containerPath": "/docker_storage",
                                                        "hostPath": "/hdd/tools/docker/registry",
                                                        "mode": "RW"
                                                    }
                                                ],
                                                "docker": {
                                                    "image": "registry",
                                                    "network": "BRIDGE",
                                                    "portMappings": [
                                                        {
                                                            "containerPort": 5000,
                                                            "hostPort": 0,
                                                            "servicePort": 5000,
                                                            "protocol": "tcp"
                                                        }
                                                    ],
                                                    "privileged": false,
                                                    "parameters": [],
                                                    "forcePullImage": false
                                                }
                                            },
                                            "healthChecks": [],
                                            "dependencies": [],
                                            "upgradeStrategy": {
                                                "minimumHealthCapacity": 1,
                                                "maximumOverCapacity": 1
                                            },
                                            "version": "2015-08-19T21:26:47.616Z",
                                            "versionInfo": {
                                                "lastScalingAt": "2015-08-19T21:26:47.616Z",
                                                "lastConfigChangeAt": "2015-08-19T21:00:54.621Z"
                                            }
                                        }
                                    ],
                                    "groups": [],
                                    "dependencies": [],
                                    "version": "2015-09-17T10:38:20.875Z"
                                }
                            ],
                            "dependencies": [],
                            "version": "2015-09-17T10:38:20.875Z"
                        }
                    ],
                    "dependencies": [],
                    "version": "2015-09-17T10:38:20.875Z"
                }
          description: The group with all transitive dependencies.
        '401':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid username or password."
                }
          description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
        '403':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Not Authorized to perform this action!"
                }
          description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
      queryParameters: {}
    put:
      description: |-
        Change parameters of a deployed application group. The new group parameters get applied.

        * Changes to application parameters will result in a restart of this application.
        * A new application added to the group will be started.
        * An existing application removed from the group will be stopped.

        If there are no changes to the application definition, no restart is triggered. During restart marathon keeps track, that the configured amount of minimal running instances are _always_ available.
        This method allows 2 special modes for the update operation>

        * Provide only the `version` field in the group definition. This will rollback the group to that given version
        * Provide only the `scaleBy` field will scale all transitive applications instance counts by the given factor.

        When one of version or scaleBy are set, nothing else than a version change or transitive instance count scaling will be applied. If both version and scaleBy are set, only a version rollback will be performed – the scaleBy value will not be applied.
        A deployment can run forever. This is the case, when the new application has a problem and does not become healthy. In this case, human interaction is needed with 2 possible choices

        * Rollback to an existing older version
        * Update with a newer version of the group which does not have the problems of the old one.

        Since the deployment of the group can take a considerable amount of time, this endpoint returns immediately with a version. The failure or success of the action is signalled via event. There is a group_change_success and group_change_failed with the given version.
      body:
        application/json:
          example: |-
            {
                "id": "/",
                "apps": [],
                "groups": [
                    {
                        "id": "/tools",
                        "apps": [
                            {
                                "id": "/tools/oauth-server",
                                "instances": 2,
                                "cpus": 1,
                                "mem": 1024,
                                "disk": 0,
                                "constraints": [
                                    [
                                        "hostname",
                                        "UNIQUE"
                                    ]
                                ],
                                "uris": [],
                                "storeUrls": [],
                                "ports": [
                                    1980
                                ],
                                "requirePorts": false,
                                "backoffSeconds": 1,
                                "backoffFactor": 1.15,
                                "maxLaunchDelaySeconds": 3600,
                                "container": {
                                    "type": "DOCKER",
                                    "volumes": [],
                                    "docker": {
                                        "image": "docker-registry/oauth_server:6d7d463cb8b1517002080a81cf23f9cf7b7fc774",
                                        "network": "HOST",
                                        "privileged": false,
                                        "parameters": [],
                                        "forcePullImage": false
                                    }
                                },
                                "healthChecks": [
                                    {
                                        "path": "/",
                                        "protocol": "HTTP",
                                        "portIndex": 0,
                                        "gracePeriodSeconds": 300,
                                        "intervalSeconds": 20,
                                        "timeoutSeconds": 20,
                                        "maxConsecutiveFailures": 3,
                                        "ignoreHttp1xx": false
                                    }
                                ],
                                "dependencies": [],
                                "upgradeStrategy": {
                                    "minimumHealthCapacity": 0.5,
                                    "maximumOverCapacity": 0
                                },
                                "version": "2015-09-28T19:47:37.681Z",
                                "versionInfo": {
                                    "lastScalingAt": "2015-09-28T19:47:37.681Z",
                                    "lastConfigChangeAt": "2015-09-28T19:47:37.681Z"
                                }
                            },
                            {
                                "id": "/tools/datadog-agent",
                                "instances": 5,
                                "cpus": 1,
                                "mem": 512,
                                "disk": 0,
                                "executor": "",
                                "constraints": [
                                    [
                                        "hostname",
                                        "UNIQUE"
                                    ]
                                ],
                                "uris": [],
                                "storeUrls": [],
                                "ports": [
                                    10018
                                ],
                                "requirePorts": false,
                                "backoffSeconds": 1,
                                "backoffFactor": 1.15,
                                "maxLaunchDelaySeconds": 3600,
                                "container": {
                                    "type": "DOCKER",
                                    "volumes": [
                                        {
                                            "containerPath": "/var/run/docker.sock",
                                            "hostPath": "/var/run/docker.sock",
                                            "mode": "RW"
                                        },
                                        {
                                            "containerPath": "/host/proc/mounts",
                                            "hostPath": "/proc/mounts",
                                            "mode": "RO"
                                        },
                                        {
                                            "containerPath": "/host/sys/fs/cgroup",
                                            "hostPath": "/sys/fs/cgroup/",
                                            "mode": "RO"
                                        }
                                    ],
                                    "docker": {
                                        "image": "datadog/docker-dd-agent:latest",
                                        "network": "HOST",
                                        "privileged": true,
                                        "parameters": [],
                                        "forcePullImage": false
                                    }
                                },
                                "healthChecks": [],
                                "dependencies": [],
                                "upgradeStrategy": {
                                    "minimumHealthCapacity": 0.5,
                                    "maximumOverCapacity": 0
                                },
                                "version": "2015-08-26T22:33:24.225Z",
                                "versionInfo": {
                                    "lastScalingAt": "2015-08-26T22:33:24.225Z",
                                    "lastConfigChangeAt": "2015-05-19T13:59:18.899Z"
                                }
                            }
                        ],
                        "groups": [
                            {
                                "id": "/tools/log",
                                "apps": [],
                                "groups": [],
                                "dependencies": [],
                                "version": "2015-09-17T10:38:20.875Z"
                            },
                            {
                                "id": "/tools/docker",
                                "apps": [
                                    {
                                        "id": "/tools/docker/registry",
                                        "instances": 1,
                                        "cpus": 0.5,
                                        "mem": 4096,
                                        "disk": 0,
                                        "executor": "",
                                        "constraints": [],
                                        "uris": [],
                                        "storeUrls": [],
                                        "ports": [
                                            5000
                                        ],
                                        "requirePorts": false,
                                        "backoffSeconds": 1,
                                        "backoffFactor": 1.15,
                                        "maxLaunchDelaySeconds": 3600,
                                        "container": {
                                            "type": "DOCKER",
                                            "volumes": [
                                                {
                                                    "containerPath": "/docker_storage",
                                                    "hostPath": "/hdd/tools/docker/registry",
                                                    "mode": "RW"
                                                }
                                            ],
                                            "docker": {
                                                "image": "registry",
                                                "network": "BRIDGE",
                                                "portMappings": [
                                                    {
                                                        "containerPort": 5000,
                                                        "hostPort": 0,
                                                        "servicePort": 5000,
                                                        "protocol": "tcp"
                                                    }
                                                ],
                                                "privileged": false,
                                                "parameters": [],
                                                "forcePullImage": false
                                            }
                                        },
                                        "healthChecks": [],
                                        "dependencies": [],
                                        "upgradeStrategy": {
                                            "minimumHealthCapacity": 1,
                                            "maximumOverCapacity": 1
                                        },
                                        "version": "2015-08-19T21:26:47.616Z",
                                        "versionInfo": {
                                            "lastScalingAt": "2015-08-19T21:26:47.616Z",
                                            "lastConfigChangeAt": "2015-08-19T21:00:54.621Z"
                                        }
                                    }
                                ],
                                "groups": [],
                                "dependencies": [],
                                "version": "2015-09-17T10:38:20.875Z"
                            }
                        ],
                        "dependencies": [],
                        "version": "2015-09-17T10:38:20.875Z"
                    }
                ],
                "dependencies": [],
                "version": "2015-09-17T10:38:20.875Z"
            }
          schema: "{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"id\": \"https://raw.githubusercontent.com/mesosphere/marathon/master/docs/docs/rest-api/public/api/v2/schema/Group.json\",\n    \"additionalProperties\": false,\n    \"definitions\": {\n        \"pathType\": {\n            \"type\": \"string\",\n            \"pattern\": \"^(\\\\/?((\\\\.{2})|([a-z0-9][a-z0-9\\\\-.]*[a-z0-9]+)|([a-z0-9]*))($|\\\\/))+$\",\n            \"minLength\": 1\n        }\n    },\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"$ref\": \"#/definitions/pathType\",\n            \"description\": \"Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.\"\n        },\n        \"apps\": {\n            \"type\": \"array\",\n            \"description\": \"The list of AppDefinitions in this group. See AppDefinition.json for the schema.\",\n            \"items\": {\n                \"$ref\": \"./AppDefinition.json\"\n            }\n        },\n        \"groups\": {\n            \"type\": \"array\",\n            \"description\": \"Groups can build a tree. Each group can contain sub-groups. The sub-groups are defined here.\",\n            \"items\": {\n                \"$ref\": \"#\"\n            }\n        },\n        \"dependencies\": {\n            \"type\": \"array\",\n            \"description\": \"A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.\",\n            \"items\": {\n                \"$ref\": \"#/definitions/pathType\"\n            }\n        },\n        \"version\": {\n            \"type\": \"string\",\n            \"description\": \"The version of this definition.\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"required\": [\n        \"id\"\n    ]\n}"
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "deploymentId": "5ed4c0c5-9ff8-4a6f-a0cd-f57f59a34b43",
                    "version": "2015-09-29T15:59:51.164Z"
                }
          description: 'A deployment is started which has a unique deployment identifier. The related deployment can be fetched from the /v2/deployments endpoint. If the deployement is gone from the list of deployments, than this means it is finished. As long as the deployment runs, the effect of that change operation is visible only partially.'
        '400':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid JSON",
                    "details": [
                        {
                            "path": "/id",
                            "errors": [
                                "error.expected.jsstring"
                            ]
                        }
                    ]
                }
          description: The group definition provided in the body is not valid.
        '401':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid username or password."
                }
          description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
        '403':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Not Authorized to perform this action!"
                }
          description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
        '409':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "App is locked by one or more deployments. Override with the option '?force=true'. View details at '/v2/deployments/<DEPLOYMENT_ID>'.",
                    "deployments": [
                        {
                            "id": "97c136bf-5a28-4821-9d94-480d9fbb01c8"
                        }
                    ]
                }
          description: 'There is an already running deployment, that affects this application. To override this deployment, use the force=true flag'
        '422':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Object is not valid",
                    "details": [
                        {
                            "attribute": "apps[0].id",
                            "error": "identifier /app is not child of /group. Hint: use relative paths."
                        }
                    ]
                }
          description: 'The entity send can not be preocessed, since there are validation errors'
      queryParameters:
        force:
          type: boolean
          description: |-
            Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
            Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
          required: false
          displayName: force
    post:
      description: Create and start a new application group. Application groups can contain other application groups.
      body:
        application/json:
          example: |-
            {
                "id": "/",
                "apps": [],
                "groups": [
                    {
                        "id": "/tools",
                        "apps": [
                            {
                                "id": "/tools/oauth-server",
                                "instances": 2,
                                "cpus": 1,
                                "mem": 1024,
                                "disk": 0,
                                "constraints": [
                                    [
                                        "hostname",
                                        "UNIQUE"
                                    ]
                                ],
                                "uris": [],
                                "storeUrls": [],
                                "ports": [
                                    1980
                                ],
                                "requirePorts": false,
                                "backoffSeconds": 1,
                                "backoffFactor": 1.15,
                                "maxLaunchDelaySeconds": 3600,
                                "container": {
                                    "type": "DOCKER",
                                    "volumes": [],
                                    "docker": {
                                        "image": "docker-registry/oauth_server:6d7d463cb8b1517002080a81cf23f9cf7b7fc774",
                                        "network": "HOST",
                                        "privileged": false,
                                        "parameters": [],
                                        "forcePullImage": false
                                    }
                                },
                                "healthChecks": [
                                    {
                                        "path": "/",
                                        "protocol": "HTTP",
                                        "portIndex": 0,
                                        "gracePeriodSeconds": 300,
                                        "intervalSeconds": 20,
                                        "timeoutSeconds": 20,
                                        "maxConsecutiveFailures": 3,
                                        "ignoreHttp1xx": false
                                    }
                                ],
                                "dependencies": [],
                                "upgradeStrategy": {
                                    "minimumHealthCapacity": 0.5,
                                    "maximumOverCapacity": 0
                                },
                                "version": "2015-09-28T19:47:37.681Z",
                                "versionInfo": {
                                    "lastScalingAt": "2015-09-28T19:47:37.681Z",
                                    "lastConfigChangeAt": "2015-09-28T19:47:37.681Z"
                                }
                            },
                            {
                                "id": "/tools/datadog-agent",
                                "instances": 5,
                                "cpus": 1,
                                "mem": 512,
                                "disk": 0,
                                "executor": "",
                                "constraints": [
                                    [
                                        "hostname",
                                        "UNIQUE"
                                    ]
                                ],
                                "uris": [],
                                "storeUrls": [],
                                "ports": [
                                    10018
                                ],
                                "requirePorts": false,
                                "backoffSeconds": 1,
                                "backoffFactor": 1.15,
                                "maxLaunchDelaySeconds": 3600,
                                "container": {
                                    "type": "DOCKER",
                                    "volumes": [
                                        {
                                            "containerPath": "/var/run/docker.sock",
                                            "hostPath": "/var/run/docker.sock",
                                            "mode": "RW"
                                        },
                                        {
                                            "containerPath": "/host/proc/mounts",
                                            "hostPath": "/proc/mounts",
                                            "mode": "RO"
                                        },
                                        {
                                            "containerPath": "/host/sys/fs/cgroup",
                                            "hostPath": "/sys/fs/cgroup/",
                                            "mode": "RO"
                                        }
                                    ],
                                    "docker": {
                                        "image": "datadog/docker-dd-agent:latest",
                                        "network": "HOST",
                                        "privileged": true,
                                        "parameters": [],
                                        "forcePullImage": false
                                    }
                                },
                                "healthChecks": [],
                                "dependencies": [],
                                "upgradeStrategy": {
                                    "minimumHealthCapacity": 0.5,
                                    "maximumOverCapacity": 0
                                },
                                "version": "2015-08-26T22:33:24.225Z",
                                "versionInfo": {
                                    "lastScalingAt": "2015-08-26T22:33:24.225Z",
                                    "lastConfigChangeAt": "2015-05-19T13:59:18.899Z"
                                }
                            }
                        ],
                        "groups": [
                            {
                                "id": "/tools/log",
                                "apps": [],
                                "groups": [],
                                "dependencies": [],
                                "version": "2015-09-17T10:38:20.875Z"
                            },
                            {
                                "id": "/tools/docker",
                                "apps": [
                                    {
                                        "id": "/tools/docker/registry",
                                        "instances": 1,
                                        "cpus": 0.5,
                                        "mem": 4096,
                                        "disk": 0,
                                        "executor": "",
                                        "constraints": [],
                                        "uris": [],
                                        "storeUrls": [],
                                        "ports": [
                                            5000
                                        ],
                                        "requirePorts": false,
                                        "backoffSeconds": 1,
                                        "backoffFactor": 1.15,
                                        "maxLaunchDelaySeconds": 3600,
                                        "container": {
                                            "type": "DOCKER",
                                            "volumes": [
                                                {
                                                    "containerPath": "/docker_storage",
                                                    "hostPath": "/hdd/tools/docker/registry",
                                                    "mode": "RW"
                                                }
                                            ],
                                            "docker": {
                                                "image": "registry",
                                                "network": "BRIDGE",
                                                "portMappings": [
                                                    {
                                                        "containerPort": 5000,
                                                        "hostPort": 0,
                                                        "servicePort": 5000,
                                                        "protocol": "tcp"
                                                    }
                                                ],
                                                "privileged": false,
                                                "parameters": [],
                                                "forcePullImage": false
                                            }
                                        },
                                        "healthChecks": [],
                                        "dependencies": [],
                                        "upgradeStrategy": {
                                            "minimumHealthCapacity": 1,
                                            "maximumOverCapacity": 1
                                        },
                                        "version": "2015-08-19T21:26:47.616Z",
                                        "versionInfo": {
                                            "lastScalingAt": "2015-08-19T21:26:47.616Z",
                                            "lastConfigChangeAt": "2015-08-19T21:00:54.621Z"
                                        }
                                    }
                                ],
                                "groups": [],
                                "dependencies": [],
                                "version": "2015-09-17T10:38:20.875Z"
                            }
                        ],
                        "dependencies": [],
                        "version": "2015-09-17T10:38:20.875Z"
                    }
                ],
                "dependencies": [],
                "version": "2015-09-17T10:38:20.875Z"
            }
          schema: "{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"id\": \"https://raw.githubusercontent.com/mesosphere/marathon/master/docs/docs/rest-api/public/api/v2/schema/Group.json\",\n    \"additionalProperties\": false,\n    \"definitions\": {\n        \"pathType\": {\n            \"type\": \"string\",\n            \"pattern\": \"^(\\\\/?((\\\\.{2})|([a-z0-9][a-z0-9\\\\-.]*[a-z0-9]+)|([a-z0-9]*))($|\\\\/))+$\",\n            \"minLength\": 1\n        }\n    },\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"$ref\": \"#/definitions/pathType\",\n            \"description\": \"Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.\"\n        },\n        \"apps\": {\n            \"type\": \"array\",\n            \"description\": \"The list of AppDefinitions in this group. See AppDefinition.json for the schema.\",\n            \"items\": {\n                \"$ref\": \"./AppDefinition.json\"\n            }\n        },\n        \"groups\": {\n            \"type\": \"array\",\n            \"description\": \"Groups can build a tree. Each group can contain sub-groups. The sub-groups are defined here.\",\n            \"items\": {\n                \"$ref\": \"#\"\n            }\n        },\n        \"dependencies\": {\n            \"type\": \"array\",\n            \"description\": \"A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.\",\n            \"items\": {\n                \"$ref\": \"#/definitions/pathType\"\n            }\n        },\n        \"version\": {\n            \"type\": \"string\",\n            \"description\": \"The version of this definition.\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"required\": [\n        \"id\"\n    ]\n}"
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "deploymentId": "5ed4c0c5-9ff8-4a6f-a0cd-f57f59a34b43",
                    "version": "2015-09-29T15:59:51.164Z"
                }
          description: 'A deployment is started which has a unique deployment identifier. The related deployment can be fetched from the /v2/deployments endpoint. If the deployement is gone from the list of deployments, than this means it is finished. As long as the deployment runs, the effect of that change operation is visible only partially.'
        '400':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid JSON",
                    "details": [
                        {
                            "path": "/id",
                            "errors": [
                                "error.expected.jsstring"
                            ]
                        }
                    ]
                }
          description: The group definition provided in the body is not valid.
        '401':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid username or password."
                }
          description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
        '403':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Not Authorized to perform this action!"
                }
          description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
        '409':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Group / is already created. Use PUT to change this group."
                }
          description: There is an already deployed group with this name
        '422':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Object is not valid",
                    "details": [
                        {
                            "attribute": "apps[0].id",
                            "error": "identifier /app is not child of /group. Hint: use relative paths."
                        }
                    ]
                }
          description: 'The entity send can not be preocessed, since there are validation errors'
      queryParameters:
        force:
          type: boolean
          description: |-
            Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
            Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
          required: false
          displayName: force
    delete:
      description: Destroy a group. All data about that group and all associated applications will be deleted. The failure or success of the action is signalled via events. There is a group_change_success and group_change_failed with the given version.
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "deploymentId": "5ed4c0c5-9ff8-4a6f-a0cd-f57f59a34b43",
                    "version": "2015-09-29T15:59:51.164Z"
                }
          description: 'A deployment is started which has a unique deployment identifier. The related deployment can be fetched from the /v2/deployments endpoint. If the deployement is gone from the list of deployments, than this means it is finished. As long as the deployment runs, the effect of that change operation is visible only partially.'
        '401':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid username or password."
                }
          description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
        '403':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Not Authorized to perform this action!"
                }
          description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
        '409':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "App is locked by one or more deployments. Override with the option '?force=true'. View details at '/v2/deployments/<DEPLOYMENT_ID>'.",
                    "deployments": [
                        {
                            "id": "97c136bf-5a28-4821-9d94-480d9fbb01c8"
                        }
                    ]
                }
          description: 'There is an already running deployment, that affects this application. To override this deployment, use the force=true flag'
      queryParameters:
        force:
          type: boolean
          description: |-
            Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
            Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
          required: false
          displayName: force
    /versions:
      displayName: versions
      description: ''
      uriParameters: {}
      get:
        description: List all versions the group with the specified path.
        responses:
          '200':
            body:
              application/json:
                schema: '{}'
                example: |-
                  [
                      "2015-09-25T15:13:48.343Z",
                      "2015-09-11T11:11:22.692Z",
                      "2015-09-11T10:47:21.241Z"
                  ]
            description: List all available versions of that group.
          '401':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid username or password."
                  }
            description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
          '403':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Not Authorized to perform this action!"
                  }
            description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
        queryParameters: {}
    '/{group_id}':
      displayName: '{group_id}'
      description: ''
      uriParameters:
        group_id:
          displayName: group_id
          type: string
      get:
        description: Get the group with all applications and all transitive child groups.
        responses:
          '200':
            body:
              application/json:
                schema: "{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"id\": \"https://raw.githubusercontent.com/mesosphere/marathon/master/docs/docs/rest-api/public/api/v2/schema/Group.json\",\n    \"additionalProperties\": false,\n    \"definitions\": {\n        \"pathType\": {\n            \"type\": \"string\",\n            \"pattern\": \"^(\\\\/?((\\\\.{2})|([a-z0-9][a-z0-9\\\\-.]*[a-z0-9]+)|([a-z0-9]*))($|\\\\/))+$\",\n            \"minLength\": 1\n        }\n    },\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"$ref\": \"#/definitions/pathType\",\n            \"description\": \"Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.\"\n        },\n        \"apps\": {\n            \"type\": \"array\",\n            \"description\": \"The list of AppDefinitions in this group. See AppDefinition.json for the schema.\",\n            \"items\": {\n                \"$ref\": \"./AppDefinition.json\"\n            }\n        },\n        \"groups\": {\n            \"type\": \"array\",\n            \"description\": \"Groups can build a tree. Each group can contain sub-groups. The sub-groups are defined here.\",\n            \"items\": {\n                \"$ref\": \"#\"\n            }\n        },\n        \"dependencies\": {\n            \"type\": \"array\",\n            \"description\": \"A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.\",\n            \"items\": {\n                \"$ref\": \"#/definitions/pathType\"\n            }\n        },\n        \"version\": {\n            \"type\": \"string\",\n            \"description\": \"The version of this definition.\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"required\": [\n        \"id\"\n    ]\n}"
                example: |-
                  {
                      "id": "/",
                      "apps": [],
                      "groups": [
                          {
                              "id": "/tools",
                              "apps": [
                                  {
                                      "id": "/tools/oauth-server",
                                      "instances": 2,
                                      "cpus": 1,
                                      "mem": 1024,
                                      "disk": 0,
                                      "constraints": [
                                          [
                                              "hostname",
                                              "UNIQUE"
                                          ]
                                      ],
                                      "uris": [],
                                      "storeUrls": [],
                                      "ports": [
                                          1980
                                      ],
                                      "requirePorts": false,
                                      "backoffSeconds": 1,
                                      "backoffFactor": 1.15,
                                      "maxLaunchDelaySeconds": 3600,
                                      "container": {
                                          "type": "DOCKER",
                                          "volumes": [],
                                          "docker": {
                                              "image": "docker-registry/oauth_server:6d7d463cb8b1517002080a81cf23f9cf7b7fc774",
                                              "network": "HOST",
                                              "privileged": false,
                                              "parameters": [],
                                              "forcePullImage": false
                                          }
                                      },
                                      "healthChecks": [
                                          {
                                              "path": "/",
                                              "protocol": "HTTP",
                                              "portIndex": 0,
                                              "gracePeriodSeconds": 300,
                                              "intervalSeconds": 20,
                                              "timeoutSeconds": 20,
                                              "maxConsecutiveFailures": 3,
                                              "ignoreHttp1xx": false
                                          }
                                      ],
                                      "dependencies": [],
                                      "upgradeStrategy": {
                                          "minimumHealthCapacity": 0.5,
                                          "maximumOverCapacity": 0
                                      },
                                      "version": "2015-09-28T19:47:37.681Z",
                                      "versionInfo": {
                                          "lastScalingAt": "2015-09-28T19:47:37.681Z",
                                          "lastConfigChangeAt": "2015-09-28T19:47:37.681Z"
                                      }
                                  },
                                  {
                                      "id": "/tools/datadog-agent",
                                      "instances": 5,
                                      "cpus": 1,
                                      "mem": 512,
                                      "disk": 0,
                                      "executor": "",
                                      "constraints": [
                                          [
                                              "hostname",
                                              "UNIQUE"
                                          ]
                                      ],
                                      "uris": [],
                                      "storeUrls": [],
                                      "ports": [
                                          10018
                                      ],
                                      "requirePorts": false,
                                      "backoffSeconds": 1,
                                      "backoffFactor": 1.15,
                                      "maxLaunchDelaySeconds": 3600,
                                      "container": {
                                          "type": "DOCKER",
                                          "volumes": [
                                              {
                                                  "containerPath": "/var/run/docker.sock",
                                                  "hostPath": "/var/run/docker.sock",
                                                  "mode": "RW"
                                              },
                                              {
                                                  "containerPath": "/host/proc/mounts",
                                                  "hostPath": "/proc/mounts",
                                                  "mode": "RO"
                                              },
                                              {
                                                  "containerPath": "/host/sys/fs/cgroup",
                                                  "hostPath": "/sys/fs/cgroup/",
                                                  "mode": "RO"
                                              }
                                          ],
                                          "docker": {
                                              "image": "datadog/docker-dd-agent:latest",
                                              "network": "HOST",
                                              "privileged": true,
                                              "parameters": [],
                                              "forcePullImage": false
                                          }
                                      },
                                      "healthChecks": [],
                                      "dependencies": [],
                                      "upgradeStrategy": {
                                          "minimumHealthCapacity": 0.5,
                                          "maximumOverCapacity": 0
                                      },
                                      "version": "2015-08-26T22:33:24.225Z",
                                      "versionInfo": {
                                          "lastScalingAt": "2015-08-26T22:33:24.225Z",
                                          "lastConfigChangeAt": "2015-05-19T13:59:18.899Z"
                                      }
                                  }
                              ],
                              "groups": [
                                  {
                                      "id": "/tools/log",
                                      "apps": [],
                                      "groups": [],
                                      "dependencies": [],
                                      "version": "2015-09-17T10:38:20.875Z"
                                  },
                                  {
                                      "id": "/tools/docker",
                                      "apps": [
                                          {
                                              "id": "/tools/docker/registry",
                                              "instances": 1,
                                              "cpus": 0.5,
                                              "mem": 4096,
                                              "disk": 0,
                                              "executor": "",
                                              "constraints": [],
                                              "uris": [],
                                              "storeUrls": [],
                                              "ports": [
                                                  5000
                                              ],
                                              "requirePorts": false,
                                              "backoffSeconds": 1,
                                              "backoffFactor": 1.15,
                                              "maxLaunchDelaySeconds": 3600,
                                              "container": {
                                                  "type": "DOCKER",
                                                  "volumes": [
                                                      {
                                                          "containerPath": "/docker_storage",
                                                          "hostPath": "/hdd/tools/docker/registry",
                                                          "mode": "RW"
                                                      }
                                                  ],
                                                  "docker": {
                                                      "image": "registry",
                                                      "network": "BRIDGE",
                                                      "portMappings": [
                                                          {
                                                              "containerPort": 5000,
                                                              "hostPort": 0,
                                                              "servicePort": 5000,
                                                              "protocol": "tcp"
                                                          }
                                                      ],
                                                      "privileged": false,
                                                      "parameters": [],
                                                      "forcePullImage": false
                                                  }
                                              },
                                              "healthChecks": [],
                                              "dependencies": [],
                                              "upgradeStrategy": {
                                                  "minimumHealthCapacity": 1,
                                                  "maximumOverCapacity": 1
                                              },
                                              "version": "2015-08-19T21:26:47.616Z",
                                              "versionInfo": {
                                                  "lastScalingAt": "2015-08-19T21:26:47.616Z",
                                                  "lastConfigChangeAt": "2015-08-19T21:00:54.621Z"
                                              }
                                          }
                                      ],
                                      "groups": [],
                                      "dependencies": [],
                                      "version": "2015-09-17T10:38:20.875Z"
                                  }
                              ],
                              "dependencies": [],
                              "version": "2015-09-17T10:38:20.875Z"
                          }
                      ],
                      "dependencies": [],
                      "version": "2015-09-17T10:38:20.875Z"
                  }
            description: The group with all transitive dependencies.
          '401':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid username or password."
                  }
            description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
          '403':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Not Authorized to perform this action!"
                  }
            description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
        queryParameters: {}
      put:
        description: |-
          Change parameters of a deployed application group. The new group parameters get applied.

          * Changes to application parameters will result in a restart of this application.
          * A new application added to the group will be started.
          * An existing application removed from the group will be stopped.

          If there are no changes to the application definition, no restart is triggered. During restart marathon keeps track, that the configured amount of minimal running instances are _always_ available.
          This method allows 2 special modes for the update operation>

          * Provide only the `version` field in the group definition. This will rollback the group to that given version
          * Provide only the `scaleBy` field will scale all transitive applications instance counts by the given factor.

          When one of version or scaleBy are set, nothing else than a version change or transitive instance count scaling will be applied. If both version and scaleBy are set, only a version rollback will be performed – the scaleBy value will not be applied.
          A deployment can run forever. This is the case, when the new application has a problem and does not become healthy. In this case, human interaction is needed with 2 possible choices

          * Rollback to an existing older version
          * Update with a newer version of the group which does not have the problems of the old one.

          Since the deployment of the group can take a considerable amount of time, this endpoint returns immediately with a version. The failure or success of the action is signalled via event. There is a group_change_success and group_change_failed with the given version.
        body:
          application/json:
            example: |-
              {
                  "id": "/",
                  "apps": [],
                  "groups": [
                      {
                          "id": "/tools",
                          "apps": [
                              {
                                  "id": "/tools/oauth-server",
                                  "instances": 2,
                                  "cpus": 1,
                                  "mem": 1024,
                                  "disk": 0,
                                  "constraints": [
                                      [
                                          "hostname",
                                          "UNIQUE"
                                      ]
                                  ],
                                  "uris": [],
                                  "storeUrls": [],
                                  "ports": [
                                      1980
                                  ],
                                  "requirePorts": false,
                                  "backoffSeconds": 1,
                                  "backoffFactor": 1.15,
                                  "maxLaunchDelaySeconds": 3600,
                                  "container": {
                                      "type": "DOCKER",
                                      "volumes": [],
                                      "docker": {
                                          "image": "docker-registry/oauth_server:6d7d463cb8b1517002080a81cf23f9cf7b7fc774",
                                          "network": "HOST",
                                          "privileged": false,
                                          "parameters": [],
                                          "forcePullImage": false
                                      }
                                  },
                                  "healthChecks": [
                                      {
                                          "path": "/",
                                          "protocol": "HTTP",
                                          "portIndex": 0,
                                          "gracePeriodSeconds": 300,
                                          "intervalSeconds": 20,
                                          "timeoutSeconds": 20,
                                          "maxConsecutiveFailures": 3,
                                          "ignoreHttp1xx": false
                                      }
                                  ],
                                  "dependencies": [],
                                  "upgradeStrategy": {
                                      "minimumHealthCapacity": 0.5,
                                      "maximumOverCapacity": 0
                                  },
                                  "version": "2015-09-28T19:47:37.681Z",
                                  "versionInfo": {
                                      "lastScalingAt": "2015-09-28T19:47:37.681Z",
                                      "lastConfigChangeAt": "2015-09-28T19:47:37.681Z"
                                  }
                              },
                              {
                                  "id": "/tools/datadog-agent",
                                  "instances": 5,
                                  "cpus": 1,
                                  "mem": 512,
                                  "disk": 0,
                                  "executor": "",
                                  "constraints": [
                                      [
                                          "hostname",
                                          "UNIQUE"
                                      ]
                                  ],
                                  "uris": [],
                                  "storeUrls": [],
                                  "ports": [
                                      10018
                                  ],
                                  "requirePorts": false,
                                  "backoffSeconds": 1,
                                  "backoffFactor": 1.15,
                                  "maxLaunchDelaySeconds": 3600,
                                  "container": {
                                      "type": "DOCKER",
                                      "volumes": [
                                          {
                                              "containerPath": "/var/run/docker.sock",
                                              "hostPath": "/var/run/docker.sock",
                                              "mode": "RW"
                                          },
                                          {
                                              "containerPath": "/host/proc/mounts",
                                              "hostPath": "/proc/mounts",
                                              "mode": "RO"
                                          },
                                          {
                                              "containerPath": "/host/sys/fs/cgroup",
                                              "hostPath": "/sys/fs/cgroup/",
                                              "mode": "RO"
                                          }
                                      ],
                                      "docker": {
                                          "image": "datadog/docker-dd-agent:latest",
                                          "network": "HOST",
                                          "privileged": true,
                                          "parameters": [],
                                          "forcePullImage": false
                                      }
                                  },
                                  "healthChecks": [],
                                  "dependencies": [],
                                  "upgradeStrategy": {
                                      "minimumHealthCapacity": 0.5,
                                      "maximumOverCapacity": 0
                                  },
                                  "version": "2015-08-26T22:33:24.225Z",
                                  "versionInfo": {
                                      "lastScalingAt": "2015-08-26T22:33:24.225Z",
                                      "lastConfigChangeAt": "2015-05-19T13:59:18.899Z"
                                  }
                              }
                          ],
                          "groups": [
                              {
                                  "id": "/tools/log",
                                  "apps": [],
                                  "groups": [],
                                  "dependencies": [],
                                  "version": "2015-09-17T10:38:20.875Z"
                              },
                              {
                                  "id": "/tools/docker",
                                  "apps": [
                                      {
                                          "id": "/tools/docker/registry",
                                          "instances": 1,
                                          "cpus": 0.5,
                                          "mem": 4096,
                                          "disk": 0,
                                          "executor": "",
                                          "constraints": [],
                                          "uris": [],
                                          "storeUrls": [],
                                          "ports": [
                                              5000
                                          ],
                                          "requirePorts": false,
                                          "backoffSeconds": 1,
                                          "backoffFactor": 1.15,
                                          "maxLaunchDelaySeconds": 3600,
                                          "container": {
                                              "type": "DOCKER",
                                              "volumes": [
                                                  {
                                                      "containerPath": "/docker_storage",
                                                      "hostPath": "/hdd/tools/docker/registry",
                                                      "mode": "RW"
                                                  }
                                              ],
                                              "docker": {
                                                  "image": "registry",
                                                  "network": "BRIDGE",
                                                  "portMappings": [
                                                      {
                                                          "containerPort": 5000,
                                                          "hostPort": 0,
                                                          "servicePort": 5000,
                                                          "protocol": "tcp"
                                                      }
                                                  ],
                                                  "privileged": false,
                                                  "parameters": [],
                                                  "forcePullImage": false
                                              }
                                          },
                                          "healthChecks": [],
                                          "dependencies": [],
                                          "upgradeStrategy": {
                                              "minimumHealthCapacity": 1,
                                              "maximumOverCapacity": 1
                                          },
                                          "version": "2015-08-19T21:26:47.616Z",
                                          "versionInfo": {
                                              "lastScalingAt": "2015-08-19T21:26:47.616Z",
                                              "lastConfigChangeAt": "2015-08-19T21:00:54.621Z"
                                          }
                                      }
                                  ],
                                  "groups": [],
                                  "dependencies": [],
                                  "version": "2015-09-17T10:38:20.875Z"
                              }
                          ],
                          "dependencies": [],
                          "version": "2015-09-17T10:38:20.875Z"
                      }
                  ],
                  "dependencies": [],
                  "version": "2015-09-17T10:38:20.875Z"
              }
            schema: "{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"id\": \"https://raw.githubusercontent.com/mesosphere/marathon/master/docs/docs/rest-api/public/api/v2/schema/Group.json\",\n    \"additionalProperties\": false,\n    \"definitions\": {\n        \"pathType\": {\n            \"type\": \"string\",\n            \"pattern\": \"^(\\\\/?((\\\\.{2})|([a-z0-9][a-z0-9\\\\-.]*[a-z0-9]+)|([a-z0-9]*))($|\\\\/))+$\",\n            \"minLength\": 1\n        }\n    },\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"$ref\": \"#/definitions/pathType\",\n            \"description\": \"Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.\"\n        },\n        \"apps\": {\n            \"type\": \"array\",\n            \"description\": \"The list of AppDefinitions in this group. See AppDefinition.json for the schema.\",\n            \"items\": {\n                \"$ref\": \"./AppDefinition.json\"\n            }\n        },\n        \"groups\": {\n            \"type\": \"array\",\n            \"description\": \"Groups can build a tree. Each group can contain sub-groups. The sub-groups are defined here.\",\n            \"items\": {\n                \"$ref\": \"#\"\n            }\n        },\n        \"dependencies\": {\n            \"type\": \"array\",\n            \"description\": \"A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.\",\n            \"items\": {\n                \"$ref\": \"#/definitions/pathType\"\n            }\n        },\n        \"version\": {\n            \"type\": \"string\",\n            \"description\": \"The version of this definition.\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"required\": [\n        \"id\"\n    ]\n}"
        responses:
          '200':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "deploymentId": "5ed4c0c5-9ff8-4a6f-a0cd-f57f59a34b43",
                      "version": "2015-09-29T15:59:51.164Z"
                  }
            description: 'A deployment is started which has a unique deployment identifier. The related deployment can be fetched from the /v2/deployments endpoint. If the deployement is gone from the list of deployments, than this means it is finished. As long as the deployment runs, the effect of that change operation is visible only partially.'
          '400':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid JSON",
                      "details": [
                          {
                              "path": "/id",
                              "errors": [
                                  "error.expected.jsstring"
                              ]
                          }
                      ]
                  }
            description: The group definition provided in the body is not valid.
          '401':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid username or password."
                  }
            description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
          '403':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Not Authorized to perform this action!"
                  }
            description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
          '409':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "App is locked by one or more deployments. Override with the option '?force=true'. View details at '/v2/deployments/<DEPLOYMENT_ID>'.",
                      "deployments": [
                          {
                              "id": "97c136bf-5a28-4821-9d94-480d9fbb01c8"
                          }
                      ]
                  }
            description: 'There is an already running deployment, that affects this application. To override this deployment, use the force=true flag'
          '422':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Object is not valid",
                      "details": [
                          {
                              "attribute": "apps[0].id",
                              "error": "identifier /app is not child of /group. Hint: use relative paths."
                          }
                      ]
                  }
            description: 'The entity send can not be preocessed, since there are validation errors'
        queryParameters:
          force:
            type: boolean
            description: |-
              Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
              Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
            required: false
            displayName: force
      post:
        description: Create and start a new application group. Application groups can contain other application groups.
        body:
          application/json:
            example: |-
              {
                  "id": "/",
                  "apps": [],
                  "groups": [
                      {
                          "id": "/tools",
                          "apps": [
                              {
                                  "id": "/tools/oauth-server",
                                  "instances": 2,
                                  "cpus": 1,
                                  "mem": 1024,
                                  "disk": 0,
                                  "constraints": [
                                      [
                                          "hostname",
                                          "UNIQUE"
                                      ]
                                  ],
                                  "uris": [],
                                  "storeUrls": [],
                                  "ports": [
                                      1980
                                  ],
                                  "requirePorts": false,
                                  "backoffSeconds": 1,
                                  "backoffFactor": 1.15,
                                  "maxLaunchDelaySeconds": 3600,
                                  "container": {
                                      "type": "DOCKER",
                                      "volumes": [],
                                      "docker": {
                                          "image": "docker-registry/oauth_server:6d7d463cb8b1517002080a81cf23f9cf7b7fc774",
                                          "network": "HOST",
                                          "privileged": false,
                                          "parameters": [],
                                          "forcePullImage": false
                                      }
                                  },
                                  "healthChecks": [
                                      {
                                          "path": "/",
                                          "protocol": "HTTP",
                                          "portIndex": 0,
                                          "gracePeriodSeconds": 300,
                                          "intervalSeconds": 20,
                                          "timeoutSeconds": 20,
                                          "maxConsecutiveFailures": 3,
                                          "ignoreHttp1xx": false
                                      }
                                  ],
                                  "dependencies": [],
                                  "upgradeStrategy": {
                                      "minimumHealthCapacity": 0.5,
                                      "maximumOverCapacity": 0
                                  },
                                  "version": "2015-09-28T19:47:37.681Z",
                                  "versionInfo": {
                                      "lastScalingAt": "2015-09-28T19:47:37.681Z",
                                      "lastConfigChangeAt": "2015-09-28T19:47:37.681Z"
                                  }
                              },
                              {
                                  "id": "/tools/datadog-agent",
                                  "instances": 5,
                                  "cpus": 1,
                                  "mem": 512,
                                  "disk": 0,
                                  "executor": "",
                                  "constraints": [
                                      [
                                          "hostname",
                                          "UNIQUE"
                                      ]
                                  ],
                                  "uris": [],
                                  "storeUrls": [],
                                  "ports": [
                                      10018
                                  ],
                                  "requirePorts": false,
                                  "backoffSeconds": 1,
                                  "backoffFactor": 1.15,
                                  "maxLaunchDelaySeconds": 3600,
                                  "container": {
                                      "type": "DOCKER",
                                      "volumes": [
                                          {
                                              "containerPath": "/var/run/docker.sock",
                                              "hostPath": "/var/run/docker.sock",
                                              "mode": "RW"
                                          },
                                          {
                                              "containerPath": "/host/proc/mounts",
                                              "hostPath": "/proc/mounts",
                                              "mode": "RO"
                                          },
                                          {
                                              "containerPath": "/host/sys/fs/cgroup",
                                              "hostPath": "/sys/fs/cgroup/",
                                              "mode": "RO"
                                          }
                                      ],
                                      "docker": {
                                          "image": "datadog/docker-dd-agent:latest",
                                          "network": "HOST",
                                          "privileged": true,
                                          "parameters": [],
                                          "forcePullImage": false
                                      }
                                  },
                                  "healthChecks": [],
                                  "dependencies": [],
                                  "upgradeStrategy": {
                                      "minimumHealthCapacity": 0.5,
                                      "maximumOverCapacity": 0
                                  },
                                  "version": "2015-08-26T22:33:24.225Z",
                                  "versionInfo": {
                                      "lastScalingAt": "2015-08-26T22:33:24.225Z",
                                      "lastConfigChangeAt": "2015-05-19T13:59:18.899Z"
                                  }
                              }
                          ],
                          "groups": [
                              {
                                  "id": "/tools/log",
                                  "apps": [],
                                  "groups": [],
                                  "dependencies": [],
                                  "version": "2015-09-17T10:38:20.875Z"
                              },
                              {
                                  "id": "/tools/docker",
                                  "apps": [
                                      {
                                          "id": "/tools/docker/registry",
                                          "instances": 1,
                                          "cpus": 0.5,
                                          "mem": 4096,
                                          "disk": 0,
                                          "executor": "",
                                          "constraints": [],
                                          "uris": [],
                                          "storeUrls": [],
                                          "ports": [
                                              5000
                                          ],
                                          "requirePorts": false,
                                          "backoffSeconds": 1,
                                          "backoffFactor": 1.15,
                                          "maxLaunchDelaySeconds": 3600,
                                          "container": {
                                              "type": "DOCKER",
                                              "volumes": [
                                                  {
                                                      "containerPath": "/docker_storage",
                                                      "hostPath": "/hdd/tools/docker/registry",
                                                      "mode": "RW"
                                                  }
                                              ],
                                              "docker": {
                                                  "image": "registry",
                                                  "network": "BRIDGE",
                                                  "portMappings": [
                                                      {
                                                          "containerPort": 5000,
                                                          "hostPort": 0,
                                                          "servicePort": 5000,
                                                          "protocol": "tcp"
                                                      }
                                                  ],
                                                  "privileged": false,
                                                  "parameters": [],
                                                  "forcePullImage": false
                                              }
                                          },
                                          "healthChecks": [],
                                          "dependencies": [],
                                          "upgradeStrategy": {
                                              "minimumHealthCapacity": 1,
                                              "maximumOverCapacity": 1
                                          },
                                          "version": "2015-08-19T21:26:47.616Z",
                                          "versionInfo": {
                                              "lastScalingAt": "2015-08-19T21:26:47.616Z",
                                              "lastConfigChangeAt": "2015-08-19T21:00:54.621Z"
                                          }
                                      }
                                  ],
                                  "groups": [],
                                  "dependencies": [],
                                  "version": "2015-09-17T10:38:20.875Z"
                              }
                          ],
                          "dependencies": [],
                          "version": "2015-09-17T10:38:20.875Z"
                      }
                  ],
                  "dependencies": [],
                  "version": "2015-09-17T10:38:20.875Z"
              }
            schema: "{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"id\": \"https://raw.githubusercontent.com/mesosphere/marathon/master/docs/docs/rest-api/public/api/v2/schema/Group.json\",\n    \"additionalProperties\": false,\n    \"definitions\": {\n        \"pathType\": {\n            \"type\": \"string\",\n            \"pattern\": \"^(\\\\/?((\\\\.{2})|([a-z0-9][a-z0-9\\\\-.]*[a-z0-9]+)|([a-z0-9]*))($|\\\\/))+$\",\n            \"minLength\": 1\n        }\n    },\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"$ref\": \"#/definitions/pathType\",\n            \"description\": \"Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.\"\n        },\n        \"apps\": {\n            \"type\": \"array\",\n            \"description\": \"The list of AppDefinitions in this group. See AppDefinition.json for the schema.\",\n            \"items\": {\n                \"$ref\": \"./AppDefinition.json\"\n            }\n        },\n        \"groups\": {\n            \"type\": \"array\",\n            \"description\": \"Groups can build a tree. Each group can contain sub-groups. The sub-groups are defined here.\",\n            \"items\": {\n                \"$ref\": \"#\"\n            }\n        },\n        \"dependencies\": {\n            \"type\": \"array\",\n            \"description\": \"A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.\",\n            \"items\": {\n                \"$ref\": \"#/definitions/pathType\"\n            }\n        },\n        \"version\": {\n            \"type\": \"string\",\n            \"description\": \"The version of this definition.\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"required\": [\n        \"id\"\n    ]\n}"
        responses:
          '200':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "deploymentId": "5ed4c0c5-9ff8-4a6f-a0cd-f57f59a34b43",
                      "version": "2015-09-29T15:59:51.164Z"
                  }
            description: 'A deployment is started which has a unique deployment identifier. The related deployment can be fetched from the /v2/deployments endpoint. If the deployement is gone from the list of deployments, than this means it is finished. As long as the deployment runs, the effect of that change operation is visible only partially.'
          '400':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid JSON",
                      "details": [
                          {
                              "path": "/id",
                              "errors": [
                                  "error.expected.jsstring"
                              ]
                          }
                      ]
                  }
            description: The group definition provided in the body is not valid.
          '401':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid username or password."
                  }
            description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
          '403':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Not Authorized to perform this action!"
                  }
            description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
          '409':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Group / is already created. Use PUT to change this group."
                  }
            description: There is an already deployed group with this name
          '422':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Object is not valid",
                      "details": [
                          {
                              "attribute": "apps[0].id",
                              "error": "identifier /app is not child of /group. Hint: use relative paths."
                          }
                      ]
                  }
            description: 'The entity send can not be preocessed, since there are validation errors'
        queryParameters:
          force:
            type: boolean
            description: |-
              Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
              Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
            required: false
            displayName: force
      delete:
        description: Destroy a group. All data about that group and all associated applications will be deleted. The failure or success of the action is signalled via events. There is a group_change_success and group_change_failed with the given version.
        responses:
          '200':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "deploymentId": "5ed4c0c5-9ff8-4a6f-a0cd-f57f59a34b43",
                      "version": "2015-09-29T15:59:51.164Z"
                  }
            description: 'A deployment is started which has a unique deployment identifier. The related deployment can be fetched from the /v2/deployments endpoint. If the deployement is gone from the list of deployments, than this means it is finished. As long as the deployment runs, the effect of that change operation is visible only partially.'
          '401':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid username or password."
                  }
            description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
          '403':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Not Authorized to perform this action!"
                  }
            description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
          '409':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "App is locked by one or more deployments. Override with the option '?force=true'. View details at '/v2/deployments/<DEPLOYMENT_ID>'.",
                      "deployments": [
                          {
                              "id": "97c136bf-5a28-4821-9d94-480d9fbb01c8"
                          }
                      ]
                  }
            description: 'There is an already running deployment, that affects this application. To override this deployment, use the force=true flag'
        queryParameters:
          force:
            type: boolean
            description: |-
              Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
              Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
            required: false
            displayName: force
      /versions:
        displayName: versions
        description: ''
        uriParameters: {}
        get:
          description: List all versions the group with the specified path.
          responses:
            '200':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    [
                        "2015-09-25T15:13:48.343Z",
                        "2015-09-11T11:11:22.692Z",
                        "2015-09-11T10:47:21.241Z"
                    ]
              description: List all available versions of that group.
            '401':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "Invalid username or password."
                    }
              description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
            '403':
              body:
                application/json:
                  schema: '{}'
                  example: |-
                    {
                        "message": "Not Authorized to perform this action!"
                    }
              description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
          queryParameters: {}
  /tasks:
    displayName: tasks
    description: ''
    uriParameters: {}
    get:
      description: List all running tasks.
      responses:
        '200':
          body:
            text/plain:
              schema: '{}'
              example: "frontend-foosball\t10019\tsrv4.example.com:31292\ntools_docker_registry\t5000\tsrv2.example.com:31721\n"
          description: 'The list of all tasks disregarding their status, or a list of tasks matching the specified status filter.'
        '401':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid username or password."
                }
          description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
        '403':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Not Authorized to perform this action!"
                }
          description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
      queryParameters:
        status:
          type: string
          description: Filter the list of tasks by status
          enum:
            - running
            - staging
          displayName: status
    /delete:
      displayName: delete
      description: ''
      uriParameters: {}
      post:
        description: Kill a list of running tasks.
        body:
          application/json:
            example: |-
              {
                  "ids": [
                      "task1",
                      "task2"
                  ]
              }
            schema: '{}'
        responses:
          '200':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "tasks": [
                          {
                              "id": "frontend-foosball.083be411-5d1f-11e5-88f7-56b91e7a505b",
                              "host": "srv4.example.com",
                              "ports": [
                                  31292
                              ],
                              "startedAt": "2015-09-17T09:32:42.598Z",
                              "stagedAt": "2015-09-17T09:32:36.822Z",
                              "version": "2015-09-17T09:32:36.583Z",
                              "slaveId": "20150707-153709-201330860-5050-12052-S0",
                              "appId": "/frontend-foosball",
                              "servicePorts": [
                                  10019
                              ]
                          },
                          {
                              "id": "tools_docker_registry.002b4d28-46b9-11e5-b731-525400cce7ed",
                              "host": "srv2.example.com",
                              "ports": [
                                  31721
                              ],
                              "startedAt": "2015-08-19T21:26:50.864Z",
                              "stagedAt": "2015-08-19T21:26:49.040Z",
                              "version": "2015-08-19T21:26:47.616Z",
                              "slaveId": null,
                              "appId": "/tools/docker/registry",
                              "servicePorts": [
                                  5000
                              ]
                          }
                      ]
                  }
            description: 'If scale=false, all tasks that were killed are returned. If scale=true, than a deployment is triggered and the deployment is returned.'
          '400':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid task id not_known"
                  }
            description: 'There are unknown task ids, that can not be killed.'
          '401':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Invalid username or password."
                  }
            description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
          '403':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "Not Authorized to perform this action!"
                  }
            description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
          '409':
            body:
              application/json:
                schema: '{}'
                example: |-
                  {
                      "message": "App is locked by one or more deployments. Override with the option '?force=true'. View details at '/v2/deployments/<DEPLOYMENT_ID>'.",
                      "deployments": [
                          {
                              "id": "97c136bf-5a28-4821-9d94-480d9fbb01c8"
                          }
                      ]
                  }
            description: 'There is an already running deployment, that affects this application. To override this deployment, use the force=true flag'
        queryParameters:
          force:
            type: boolean
            description: |-
              Only one deployment can be applied to one application at the same time. If the existing deployment should be canceled by this change, you can set force=true.
              Caution&#58; setting force=true will cancel the current deployment. This paramter should be used only, if the current deployment is unsuccessful!
            required: false
            displayName: force
          scale:
            type: boolean
            description: 'If `scale=true` is specified, then the related application is scaled down by the number of killed tasks.'
            displayName: scale
  /artifacts:
    displayName: artifacts
    description: ''
    uriParameters: {}
    post:
      description: 'Upload an artifact to the artifact store. A multipart form upload request has to be performed. The form parameter name has to be ```file```. The filename used in the artifact store, is the same as given by the form parameter. The response holds the URL of the artifact in the artifact store in the Location Header.'
      body:
        multipart/form-data:
          formParameters:
            file:
              type: file
              description: The file to upload
      responses: {}
      queryParameters: {}
    '/{path}':
      displayName: '{path}'
      description: ''
      uriParameters:
        path:
          displayName: path
          type: string
      put:
        description: Upload an artifact to the artifact store. A multipart form upload request has to be performed. The form parameter name has to be ```file```. The path used to store the file is taken from the url path. The response holds the URL of the artifact in the artifact store in the Location Header.
        body:
          multipart/form-data:
            formParameters:
              file:
                type: file
                description: The file to upload
        responses: {}
        queryParameters: {}
      post:
        description: Upload an artifact to the artifact store. A multipart form upload request has to be performed. The form parameter name has to be ```file```. The path used to store the file is taken from the url path. The response holds the URL of the artifact in the artifact store in the Location Header.
        body:
          multipart/form-data:
            formParameters:
              file:
                type: file
                description: The file to upload
        responses: {}
        queryParameters: {}
      delete:
        description: Delete an artifact from the artifact store. The path is the relative path in the artifact store.
        responses: {}
        queryParameters: {}
      get:
        description: Download an artifact from the artifact store. The path is the relative path in the artifact store.
        responses: {}
        queryParameters: {}
  /events:
    displayName: events
    description: ''
    uriParameters: {}
    get:
      description: |-
        Attach to the marathon event stream.
        To use this endpoint, the client has to accept the text/event-stream content type.
        Please note a request to this endpoint will not be closed by the server. If an event happens on the server side, this event will be propagated to the client immediately. See [Server Sent Events](http://www.w3schools.com/html/html5_serversentevents.asp) for a more detailed explanation.
        Note for ApiConsole&#58; this function will not yield the expected result from inside ApiConsole.
      responses:
        '200':
          body:
            text/event-stream:
              schema: '{}'
              example: |+
                event: event_stream_attached
                data: {"remoteAddress":"0:0:0:0:0:0:0:1","eventType":"event_stream_attached","timestamp":"2015-09-30T12:44:30.061Z"}

                event: status_update_event
                data: {"slaveId":"20150707-153709-218108076-5050-25588-S6","taskId":"foo.0664256e-6771-11e5-94e1-be5b2935a987","taskStatus":"TASK_FAILED","message":"Failed to launch container: Failed to fetch all URIs for container '59d5cd89-091f-4454-940a-d9eb4361c640' with exit status: 256","appId":"/foo","host":"srv5.hw.ca1.mesosphere.com","ports":[31776],"version":"2015-09-30T09:09:17.614Z","eventType":"status_update_event","timestamp":"2015-09-30T12:44:45.681Z"}

                event: status_update_event
                data: {"slaveId":"20150707-153709-201330860-5050-12052-S0","taskId":"test-app.5dd78972-6771-11e5-94e1-be5b2935a987","taskStatus":"TASK_RUNNING","message":"","appId":"/test-app","host":"srv4.hw.ca1.mesosphere.com","ports":[31182],"version":"2015-09-11T22:11:03.156Z","eventType":"status_update_event","timestamp":"2015-09-30T12:47:11.286Z"}



          description: the list of all tasks waiting to be scheduled.
        '405':
          body:
            text/html:
              schema: '{}'
              example: |
                <html>
                <head>
                <meta http-equiv="Content-Type" content="text/html;charset=ISO-8859-1"/>
                <title>Error 405 </title>
                </head>
                <body>
                <h2>HTTP ERROR: 405</h2>
                <p>Problem accessing /v2/events. Reason:
                <pre>    HTTP method GET is not supported by this URL</pre></p>
                <hr /><a href="http://eclipse.org/jetty">Powered by Jetty:// 9.3.z-SNAPSHOT</a><hr/>
                </body>
                </html>
          description: A request has been made without the correct Accept Header
      queryParameters: {}
  /eventSubscriptions:
    displayName: eventSubscriptions
    description: ''
    uriParameters: {}
    get:
      description: 'List all event subscriber callback URLs. _NOTE To activate this endpoint, you need to startup a Marathon instance with `--event_subscriber http_callback`_'
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "callbackUrls": [
                        "http://server123:9090/callback",
                        "http://server234:9191/callback"
                    ]
                }
          description: Return the list of all subscription endpoints
      queryParameters: {}
    post:
      description: Subscribe to the event callback mechanism with the specified callback URL.
      body: {}
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "callbackUrl": "http://localhost:9292/callback",
                    "clientIp": "127.0.0.1",
                    "eventType": "subscribe_event"
                }
      queryParameters:
        callbackUrl:
          type: string
          description: The URL to an endpoint that is able to handle post requests for every event that is send.
          pattern: "^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$"
          displayName: callbackUrl
    delete:
      description: Unregister a callback URL from the event subscribers list.
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "callbackUrl": "http://localhost:9292/callback",
                    "clientIp": "127.0.0.1",
                    "eventType": "unsubscribe_event"
                }
      queryParameters:
        callbackUrl:
          type: string
          description: The URL to an endpoint that is able to handle post requests for every event that is send.
          pattern: "^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$"
          displayName: callbackUrl
  /info:
    displayName: info
    description: ''
    uriParameters: {}
    get:
      description: Get info about the Marathon Instance
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "name": "marathon",
                    "version": "0.13.0-SNAPSHOT",
                    "elected": true,
                    "leader": "wrk.fritz.box:8080",
                    "frameworkId": "80ba2050-bf0f-4472-a2f7-2636c4f7b8c8-0000",
                    "marathon_config": {
                        "master": "127.0.0.1:5050",
                        "failover_timeout": 604800,
                        "framework_name": "marathon",
                        "ha": true,
                        "checkpoint": true,
                        "local_port_min": 10000,
                        "local_port_max": 20000,
                        "executor": "//cmd",
                        "hostname": "wrk.fritz.box",
                        "webui_url": null,
                        "mesos_role": null,
                        "task_launch_timeout": 300000,
                        "reconciliation_initial_delay": 15000,
                        "reconciliation_interval": 300000,
                        "marathon_store_timeout": 2000,
                        "mesos_user": "matthias",
                        "leader_proxy_connection_timeout_ms": 5000,
                        "leader_proxy_read_timeout_ms": 10000,
                        "mesos_leader_ui_url": null
                    },
                    "zookeeper_config": {
                        "zk": "zk://localhost:2181/marathon",
                        "zk_timeout": 10000,
                        "zk_session_timeout": 1800000,
                        "zk_max_versions": 25
                    },
                    "event_subscriber": null,
                    "http_config": {
                        "assets_path": null,
                        "http_port": 8080,
                        "https_port": 8443
                    }
                }
          description: General configuration and runtime information about this Marathon instance.
      queryParameters: {}
  /leader:
    displayName: leader
    description: ''
    uriParameters: {}
    get:
      description: Returns the current leader.
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "leader": "marathon.globalcorp.com:8080"
                }
          description: The host and port of the current leading master.
        '404':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "There is no leader"
                }
          description: If there is no current leader.
      queryParameters: {}
    delete:
      description: 'Causes the current leader to abdicate, triggering a new election.'
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Leadership abdicated"
                }
          description: The abdication message from the current leader.
        '404':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "There is no leader"
                }
          description: If there is no current leader.
      queryParameters: {}
  /plugins:
    displayName: plugins
    description: ''
    uriParameters: {}
    get:
      description: Returns the list of all loaded plugins
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "plugins": [
                        {
                            "id": "webjar",
                            "implementation": "mesosphere.marathon.example.plugin.http.WebJarHandler",
                            "info": {
                                "version": "1.2.3",
                                "array": [
                                    1,
                                    2,
                                    3,
                                    4,
                                    5,
                                    6
                                ],
                                "test": true
                            },
                            "plugin": "mesosphere.marathon.plugin.http.HttpRequestHandler",
                            "tags": [
                                "webjar",
                                "test"
                            ]
                        }
                    ]
                }
          description: The list of all loaded plugins
      queryParameters: {}
    '/{plugin_id}':
      displayName: '{plugin_id}'
      description: ''
      '/{path}':
        displayName: '{path}'
        description: ''
        uriParameters:
          path:
            displayName: path
            type: string
        get:
          description: Get request is handled by the plugin.
          responses: {}
          queryParameters: {}
        put:
          description: Put request is handled by the plugin.
          body: {}
          responses: {}
          queryParameters: {}
        post:
          description: Post request is handled by the plugin.
          body: {}
          responses: {}
          queryParameters: {}
        delete:
          description: Delete request is handled by the plugin.
          responses: {}
          queryParameters: {}
  /queue:
    displayName: queue
    description: ''
    uriParameters: {}
    get:
      description: |-
        List all the tasks queued up or waiting to be scheduled. This is mainly used for troubleshooting and occurs when scaling changes are requested and the volume of scaling changes out paces the ability to schedule those tasks.
        In addition to the application in the queue, you see also the task count that needs to be started.
        If the task has a rate limit, then a delay to the start gets applied. You can see this delay for every application with the seconds to wait before the next launch will be tried.
      responses:
        '200':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "queue": [
                        {
                            "app": {
                                "id": "/tools/datadog-agent",
                                "cmd": null,
                                "args": null,
                                "user": null,
                                "env": {},
                                "instances": 5,
                                "cpus": 1,
                                "mem": 512,
                                "disk": 0,
                                "executor": "",
                                "constraints": [
                                    [
                                        "hostname",
                                        "UNIQUE"
                                    ]
                                ],
                                "uris": [],
                                "storeUrls": [],
                                "ports": [
                                    10018
                                ],
                                "requirePorts": false,
                                "backoffSeconds": 1,
                                "backoffFactor": 1.15,
                                "maxLaunchDelaySeconds": 3600,
                                "container": {
                                    "type": "DOCKER",
                                    "volumes": [],
                                    "docker": {
                                        "image": "datadog/docker-dd-agent:latest",
                                        "network": "HOST",
                                        "privileged": true,
                                        "parameters": [],
                                        "forcePullImage": false
                                    }
                                },
                                "healthChecks": [],
                                "dependencies": [],
                                "upgradeStrategy": {
                                    "minimumHealthCapacity": 0.5,
                                    "maximumOverCapacity": 0
                                },
                                "labels": {},
                                "acceptedResourceRoles": null,
                                "version": "2015-08-26T22:33:24.225Z",
                                "versionInfo": {
                                    "lastScalingAt": "2015-08-26T22:33:24.225Z",
                                    "lastConfigChangeAt": "2015-05-19T13:59:18.899Z"
                                }
                            },
                            "count": 1,
                            "delay": {
                                "timeLeftSeconds": 0,
                                "overdue": true
                            }
                        },
                        {
                            "app": {
                                "id": "/foo",
                                "cmd": null,
                                "args": null,
                                "user": "root",
                                "env": {
                                    "MASTER": "zk://172.16.0.12:2181,172.16.0.13:2181,172.16.0.14:2181/mesos"
                                },
                                "instances": 1,
                                "cpus": 0.5,
                                "mem": 128,
                                "disk": 0,
                                "executor": "//cmd",
                                "constraints": [
                                    [
                                        "hostname",
                                        "UNIQUE"
                                    ]
                                ],
                                "uris": [
                                    "http://www.mesosphere.io/index.html"
                                ],
                                "storeUrls": [],
                                "ports": [
                                    10010
                                ],
                                "requirePorts": false,
                                "backoffSeconds": 1,
                                "backoffFactor": 1.15,
                                "maxLaunchDelaySeconds": 3600,
                                "container": {
                                    "type": "DOCKER",
                                    "volumes": [],
                                    "docker": {
                                        "image": "thomasr/dispatch",
                                        "network": "HOST",
                                        "privileged": false,
                                        "parameters": [],
                                        "forcePullImage": false
                                    }
                                },
                                "healthChecks": [],
                                "dependencies": [],
                                "upgradeStrategy": {
                                    "minimumHealthCapacity": 1,
                                    "maximumOverCapacity": 1
                                },
                                "labels": {},
                                "acceptedResourceRoles": null,
                                "version": "2015-09-30T09:09:17.614Z",
                                "versionInfo": {
                                    "lastScalingAt": "2015-09-30T09:09:17.614Z",
                                    "lastConfigChangeAt": "2015-09-30T09:09:17.614Z"
                                }
                            },
                            "count": 2,
                            "delay": {
                                "timeLeftSeconds": 0,
                                "overdue": true
                            }
                        }
                    ]
                }
          description: the list of all tasks waiting to be scheduled.
        '401':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Invalid username or password."
                }
          description: Unauthorized. Authentication is enabled and you did not provide enough or wrong information to authenticate that request.
        '403':
          body:
            application/json:
              schema: '{}'
              example: |-
                {
                    "message": "Not Authorized to perform this action!"
                }
          description: Forbidden. Authorization is granted but the identity provided does not have sufficient access rights to do that action.
      queryParameters: {}
    '/{app_id}':
      displayName: '{app_id}'
      description: ''
      /delay:
        displayName: delay
        description: ''
        uriParameters: {}
        delete:
          description: 'If an application fails too often in a specified amount of time (according to the application definition), the task launch will be delayed. This delay can be removed by calling this endpoint. The effect is, that the tasks of this application will be launched immediately.'
          responses: {}
          queryParameters: {}
/ping:
  displayName: ping
  description: ''
  uriParameters: {}
  get:
    description: Ping this Marathon instance.
    responses:
      '200':
        body:
          text/plain:
            schema: '{}'
            example: pong
        description: Every ping is answered with a pong.
    queryParameters: {}
/metrics:
  displayName: metrics
  description: ''
  uriParameters: {}
  get:
    description: Get metrics data from this Marathon instance
    responses:
      '200':
        body:
          application/json:
            schema: '{}'
            example: |-
              {
                  "counters": {
                      "name.of.counter": {
                          "count": 1
                      }
                  },
                  "gauges": {
                      "name.of.gauge": {
                          "value": 7248
                      }
                  },
                  "histograms": {
                      "name.of.histogram": {
                          "count": 0,
                          "max": 0,
                          "mean": 0,
                          "min": 0,
                          "p50": 0,
                          "p75": 0,
                          "p95": 0,
                          "p98": 0,
                          "p99": 0,
                          "p999": 0,
                          "stddev": 0
                      }
                  },
                  "meters": {
                      "name.of.meter": {
                          "count": 0,
                          "m15_rate": 0,
                          "m1_rate": 0,
                          "m5_rate": 0,
                          "mean_rate": 0,
                          "units": "events/second"
                      }
                  },
                  "timers": {
                      "name.of.timer": {
                          "count": 1,
                          "duration_units": "seconds",
                          "m15_rate": 0.2,
                          "m1_rate": 0.2,
                          "m5_rate": 0.2,
                          "max": 0.0021718640000000003,
                          "mean": 0.0021718640000000003,
                          "mean_rate": 0.13897812037014803,
                          "min": 0.0021718640000000003,
                          "p50": 0.0021718640000000003,
                          "p75": 0.0021718640000000003,
                          "p95": 0.0021718640000000003,
                          "p98": 0.0021718640000000003,
                          "p99": 0.0021718640000000003,
                          "p999": 0.0021718640000000003,
                          "rate_units": "calls/second",
                          "stddev": 0
                      }
                  },
                  "version": "3.0.0"
              }
        description: All aggregated runtime metrics for this Marathon instance.
    queryParameters: {}
schemas:
  - AppDefinition: "{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"additionalProperties\": false,\n    \"definitions\": {\n        \"pathType\": {\n            \"type\": \"string\",\n            \"pattern\": \"^(\\\\/?((\\\\.{2})|([a-z0-9][a-z0-9\\\\-.]*[a-z0-9]+)|([a-z0-9]*))($|\\\\/))+$\",\n            \"minLength\": 1\n        }\n    },\n    \"not\": {\n        \"allOf\": [\n            {\n                \"required\": [\n                    \"cmd\"\n                ]\n            },\n            {\n                \"required\": [\n                    \"args\"\n                ]\n            }\n        ]\n    },\n    \"properties\": {\n        \"acceptedResourceRoles\": {\n            \"items\": {\n                \"type\": \"string\"\n            },\n            \"type\": \"array\",\n            \"description\": \"Optional. A list of resource roles. Marathon considers only resource offers with roles in this list for launching tasks of this app. If you do not specify this, Marathon considers all resource offers with roles that have been configured by the `--default_accepted_resource_roles` command line flag. If no `--default_accepted_resource_roles` was given on startup, Marathon considers all resource offers. To register Marathon for a role, you need to specify the `--mesos_role` command line flag on startup. If you want to assign all resources of a slave to a role, you can use the `--default_role` argument when starting up the slave. If you need a more fine-grained configuration, you can use the `--resources` argument to specify resource shares per role. The Mesos master needs to be started with `--roles` followed by a comma-separated list of all roles you want to use across your cluster. See [the Mesos command line documentation](http://mesos.apache.org/documentation/latest/configuration/) for details.\"\n        },\n        \"args\": {\n            \"items\": {\n                \"type\": \"string\"\n            },\n            \"type\": \"array\",\n            \"description\": \"An array of strings that represents an alternative mode of specifying the command to run. This was motivated by safe usage of containerizer features like a custom Docker ENTRYPOINT. This args field may be used in place of cmd even when using the default command executor. This change mirrors API and semantics changes in the Mesos CommandInfo protobuf message starting with version `0.20.0`.  Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same app.\"\n        },\n        \"backoffFactor\": {\n            \"minimum\": 1,\n            \"type\": \"number\",\n            \"description\": \"Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.\"\n        },\n        \"backoffSeconds\": {\n            \"description\": \"Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.\",\n            \"minimum\": 0,\n            \"type\": \"integer\"\n        },\n        \"cmd\": {\n            \"description\": \"The command that is executed.  This value is wrapped by Mesos via `/bin/sh -c ${app.cmd}`.  Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same app.\",\n            \"type\": \"string\",\n            \"minLength\": 1\n        },\n        \"constraints\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"array\",\n                \"items\": [\n                    {\n                        \"type\": \"string\"\n                    },\n                    {\n                        \"type\": \"string\",\n                        \"enum\": [\n                            \"UNIQUE\",\n                            \"CLUSTER\",\n                            \"GROUP_BY\",\n                            \"LIKE\",\n                            \"UNLIKE\"\n                        ]\n                    },\n                    {\n                        \"type\": \"string\"\n                    }\n                ],\n                \"minItems\": 2,\n                \"additionalItems\": false\n            },\n            \"description\": \"Valid constraint operators are one of UNIQUE, CLUSTER, GROUP_BY, LIKE, UNLIKE.\"\n        },\n        \"container\": {\n            \"additionalProperties\": false,\n            \"properties\": {\n                \"docker\": {\n                    \"additionalProperties\": false,\n                    \"properties\": {\n                        \"forcePullImage\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"The container will be pulled, regardless if it is already available on the local system.\"\n                        },\n                        \"image\": {\n                            \"type\": \"string\",\n                            \"minLength\": 1,\n                            \"description\": \"The name of the docker image to use.\"\n                        },\n                        \"network\": {\n                            \"type\": \"string\",\n                            \"description\": \"The networking mode, this container should operate in. One of BRIDGED|HOST|NONE\",\n                            \"enum\": [\n                                \"BRIDGE\",\n                                \"HOST\",\n                                \"NONE\"\n                            ]\n                        },\n                        \"parameters\": {\n                            \"type\": \"array\",\n                            \"description\": \"Allowing arbitrary parameters to be passed to docker CLI. Note that anything passed to this field is not guaranteed to be supported moving forward, as we might move away from the docker CLI.\",\n                            \"items\": {\n                                \"type\": \"object\",\n                                \"additionalProperties\": false,\n                                \"properties\": {\n                                    \"key\": {\n                                        \"type\": \"string\",\n                                        \"minLength\": 1,\n                                        \"description\": \"Key of this parameter\"\n                                    },\n                                    \"value\": {\n                                        \"type\": \"string\",\n                                        \"description\": \"Value of this parameter\"\n                                    }\n                                },\n                                \"required\": [\n                                    \"key\",\n                                    \"value\"\n                                ]\n                            }\n                        },\n                        \"portMappings\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"object\",\n                                \"additionalProperties\": false,\n                                \"properties\": {\n                                    \"containerPort\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Refers to the port the application listens to inside of the container. It is optional and now defaults to 0, in which case Marathon assigns the container port the same value as the assigned hostPort. This is especially useful for apps that advertise the port they are listening on to the outside world for P2P communication. Without containerPort: 0 they would erroneously advertise their private container port which is usually not the same as the externally visible host port.\",\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0\n                                    },\n                                    \"hostPort\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Retains the traditional meaning in Marathon, which is a random port from the range included in the Mesos resource offer. The resulting host ports for each task are exposed via the task details in the REST API and the Marathon web UI. hostPort is optional and defaults to 0.\",\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0\n                                    },\n                                    \"protocol\": {\n                                        \"type\": \"string\",\n                                        \"description\": \"parameter is optional and defaults to tcp.\"\n                                    },\n                                    \"servicePort\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Is a helper port intended for doing service discovery using a well-known port per service. The assigned servicePort value is not used/interpreted by Marathon itself but supposed to used by load balancer infrastructure. See Service Discovery Load Balancing doc page. The servicePort parameter is optional and defaults to 0. Like hostPort, If the value is 0, a random port will be assigned. If a servicePort value is assigned by Marathon then Marathon guarantees that its value is unique across the cluster. The values for random service ports are in the range [local_port_min, local_port_max] where local_port_min and local_port_max are command line options with default values of 10000 and 20000, respectively.\",\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0\n                                    }\n                                }\n                            }\n                        },\n                        \"privileged\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Run this docker image in privileged mode.\"\n                        }\n                    },\n                    \"required\": [\n                        \"image\"\n                    ],\n                    \"type\": \"object\"\n                },\n                \"type\": {\n                    \"type\": \"string\",\n                    \"description\": \"Supported container types at the moment are DOCKER and MESOS.\",\n                    \"enum\": [\n                        \"MESOS\",\n                        \"DOCKER\"\n                    ]\n                },\n                \"volumes\": {\n                    \"items\": {\n                        \"additionalProperties\": false,\n                        \"properties\": {\n                            \"containerPath\": {\n                                \"type\": \"string\",\n                                \"description\": \"The path of the volume in the container\",\n                                \"minLength\": 1\n                            },\n                            \"hostPath\": {\n                                \"type\": \"string\",\n                                \"description\": \"The path of the volume on the host\",\n                                \"minLength\": 1\n                            },\n                            \"persistent\": {\n                                \"additionalProperties\": false,\n                                \"properties\": {\n                                    \"size\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"The size of the persistent volume in MiB\",\n                                        \"minimum\": 0\n                                    }\n                                },\n                                \"type\": \"object\"\n                            },\n                            \"mode\": {\n                                \"type\": \"string\",\n                                \"description\": \"Possible values are RO for ReadOnly and RW for Read/Write\",\n                                \"enum\": [\n                                    \"RO\",\n                                    \"RW\"\n                                ]\n                            }\n                        },\n                        \"type\": \"object\"\n                    },\n                    \"type\": \"array\"\n                }\n            },\n            \"type\": \"object\"\n        },\n        \"cpus\": {\n            \"type\": \"number\",\n            \"description\": \"The number of CPU shares this application needs per instance. This number does not have to be integer, but can be a fraction.\",\n            \"minimum\": 0\n        },\n        \"dependencies\": {\n            \"type\": \"array\",\n            \"description\": \"A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.\",\n            \"items\": {\n                \"$ref\": \"#/definitions/pathType\"\n            }\n        },\n        \"disk\": {\n            \"type\": \"number\",\n            \"description\": \"How much disk space is needed for this application. This number does not have to be an integer, but can be a fraction.\",\n            \"minimum\": 0\n        },\n        \"env\": {\n            \"patternProperties\": {\n                \".*\": {\n                    \"type\": \"string\"\n                }\n            },\n            \"type\": \"object\"\n        },\n        \"executor\": {\n            \"type\": \"string\",\n            \"description\": \"The executor to use to launch this application. Different executors are available. The simplest one (and the default if none is given) is //cmd, which takes the cmd and executes that on the shell level.\",\n            \"pattern\": \"^(|\\\\/\\\\/cmd|\\\\/?[^\\\\/]+(\\\\/[^\\\\/]+)*)$\"\n        },\n        \"fetch\": {\n            \"type\": \"array\",\n            \"description\": \"Provided URIs are passed to Mesos fetcher module and resolved in runtime.\",\n            \"items\": {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"properties\": {\n                    \"uri\": {\n                        \"type\": \"string\",\n                        \"description\": \"URI to be fetched by Mesos fetcher module\"\n                    },\n                    \"executable\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Set fetched artifact as executable\"\n                    },\n                    \"extract\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Extract fetched artifact if supported by Mesos fetcher module\"\n                    },\n                    \"cache\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Cache fetched artifact if supported by Mesos fetcher module\"\n                    }\n                },\n                \"required\": [\n                    \"uri\"\n                ]\n            }\n        },\n        \"healthChecks\": {\n            \"items\": {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"properties\": {\n                    \"command\": {\n                        \"type\": \"object\",\n                        \"items\": {\n                            \"additionalProperties\": false,\n                            \"properties\": {\n                                \"value\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"The health check command to execute.\"\n                                }\n                            }\n                        }\n                    },\n                    \"gracePeriodSeconds\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Health check failures are ignored within this number of seconds of the task being started or until the task becomes healthy for the first time.\",\n                        \"minimum\": 0\n                    },\n                    \"ignoreHttp1xx\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Ignore HTTP 1xx responses.\"\n                    },\n                    \"intervalSeconds\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Number of seconds to wait between health checks.\",\n                        \"minimum\": 0\n                    },\n                    \"maxConsecutiveFailures\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Number of consecutive health check failures after which the unhealthy task should be killed.\",\n                        \"minimum\": 0\n                    },\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"Path to endpoint exposed by the task that will provide health status. Example: /path/to/health. Note: only used if protocol == HTTP[S].\"\n                    },\n                    \"port\": {\n                        \"type\": \"integer\",\n                        \"description\": \"The specific port to connect to. In case of dynamic ports, see portIndex.\",\n                        \"maximum\": 65535,\n                        \"minimum\": 0\n                    },\n                    \"portIndex\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Index in this app's ports array to be used for health requests. An index is used so the app can use random ports, like [0, 0, 0] for example, and tasks could be started with port environment variables like $PORT1.\",\n                        \"minimum\": 0\n                    },\n                    \"protocol\": {\n                        \"type\": \"string\",\n                        \"description\": \"Protocol of the requests to be performed. One of HTTP, HTTPS, TCP or COMMAND.\",\n                        \"enum\": [\n                            \"HTTP\",\n                            \"HTTPS\",\n                            \"TCP\",\n                            \"COMMAND\"\n                        ]\n                    },\n                    \"timeoutSeconds\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Number of seconds after which a health check is considered a failure regardless of the response.\",\n                        \"minimum\": 0\n                    }\n                }\n            },\n            \"type\": \"array\"\n        },\n        \"id\": {\n            \"$ref\": \"#/definitions/pathType\",\n            \"description\": \"Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.\"\n        },\n        \"instances\": {\n            \"type\": \"integer\",\n            \"description\": \"The number of instances of this application to start. Please note: this number can be changed any time as needed to scale the application.\",\n            \"minimum\": 0\n        },\n        \"labels\": {\n            \"type\": \"object\",\n            \"description\": \"Attaching metadata to apps can be useful to expose additional information to other services, so we added the ability to place labels on apps (for example, you could label apps staging and production to mark services by their position in the pipeline).\",\n            \"additionalProperties\": {\n                \"type\": \"string\"\n            }\n        },\n        \"maxLaunchDelaySeconds\": {\n            \"type\": \"integer\",\n            \"description\": \"Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks.\",\n            \"minimum\": 0\n        },\n        \"mem\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of memory in MB that is needed for the application per instance.\",\n            \"minimum\": 0\n        },\n        \"ipAddress\": {\n            \"type\": \"object\",\n            \"description\": \"If an application definition includes the 'ipAddress' field, then Marathon will request a per-task IP from Mesos. A separate ports/portMappings configuration is then disallowed.\",\n            \"properties\": {\n                \"discovery\": {\n                    \"type\": \"object\",\n                    \"description\": \"Information useful for service discovery.\",\n                    \"properties\": {\n                        \"ports\": {\n                            \"type\": \"array\",\n                            \"description\": \"Array of objects describing the ports exposed by each task.\",\n                            \"items\": {\n                                \"type\": \"object\",\n                                \"description\": \"Port\",\n                                \"properties\": {\n                                    \"number\": {\n                                        \"maximum\": 65535,\n                                        \"minimum\": 0,\n                                        \"type\": \"integer\",\n                                        \"description\": \"The port number.\"\n                                    },\n                                    \"name\": {\n                                        \"type\": \"string\",\n                                        \"description\": \"Name of the port.\",\n                                        \"pattern\": \"^[a-z][a-z0-9-]*$\"\n                                    },\n                                    \"protocol\": {\n                                        \"enum\": [\n                                            \"tcp\",\n                                            \"udp\"\n                                        ],\n                                        \"description\": \"Protocol of the port (one of ['tcp', 'udp']).\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n                \"groups\": {\n                    \"type\": \"array\",\n                    \"description\": \"Array of network groups. One IP address can belong to zero or more network groups. The idea is that containers can only reach containers with which they share at least one network group.\",\n                    \"items\": {\n                        \"type\": \"string\",\n                        \"description\": \"The name of the network group.\"\n                    }\n                },\n                \"labels\": {\n                    \"type\": \"object\",\n                    \"description\": \"Key value pair for meta data on that network interface.\",\n                    \"properties\": {},\n                    \"additionalProperties\": true\n                }\n            }\n        },\n        \"ports\": {\n            \"type\": \"array\",\n            \"description\": \"An array of required port resources on the agent host. The number of items in the array determines how many dynamic ports are allocated for every task. For every port that is zero, a globally unique (cluster-wide) port is assigned and provided as part of the app definition to be used in load balancing definitions.\",\n            \"items\": {\n                \"maximum\": 65535,\n                \"minimum\": 0,\n                \"type\": \"integer\"\n            }\n        },\n        \"residency\": {\n            \"type\": \"object\",\n            \"description\": \"When using local persistent volumes that pin tasks onto agents, these values define how Marathon handles terminal states of these tasks.\",\n            \"properties\": {\n                \"relaunchEscalationTimeoutSeconds\": {\n                    \"type\": \"integer\",\n                    \"description\": \"When a task using persistent local volumes cannot be restarted on the agent it's been pinned to, Marathon will try to launch this task on another node after this timeout. Defaults to 3600 (one hour).\",\n                    \"minimum\": 0,\n                    \"additionalProperties\": false\n                },\n                \"taskLostBehavior\": {\n                    \"type\": \"string\",\n                    \"description\": \"When Marathon receives a TASK_LOST status update indicating that the agent running the task is gone, this property defines whether Marathon will launch the task on another node or not. Defaults to WAIT_FOREVER\",\n                    \"enum\": [\n                        \"WAIT_FOREVER\",\n                        \"RELAUNCH_AFTER_TIMEOUT\"\n                    ],\n                    \"additionalProperties\": false\n                }\n            },\n            \"additionalProperties\": false\n        },\n        \"requirePorts\": {\n            \"type\": \"boolean\",\n            \"description\": \"Normally, the host ports of your tasks are automatically assigned. This corresponds to the requirePorts value false which is the default. If you need more control and want to specify your host ports in advance, you can set requirePorts to true. This way the ports you have specified are used as host ports. That also means that Marathon can schedule the associated tasks only on hosts that have the specified ports available.\"\n        },\n        \"storeUrls\": {\n            \"type\": \"array\",\n            \"description\": \"URL's that have to be resolved and put into the artifact store, before the task will be started.\",\n            \"items\": {\n                \"type\": \"string\",\n                \"minLength\": 1\n            }\n        },\n        \"upgradeStrategy\": {\n            \"type\": \"object\",\n            \"description\": \"During an upgrade all instances of an application get replaced by a new version. The upgradeStrategy controls how Marathon stops old versions and launches new versions.\",\n            \"additionalProperties\": false,\n            \"properties\": {\n                \"maximumOverCapacity\": {\n                    \"type\": \"number\",\n                    \"description\": \"A number between 0 and 1 which is multiplied with the instance count. This is the maximum number of additional instances launched at any point of time during the upgrade process.\",\n                    \"maximum\": 1,\n                    \"minimum\": 0\n                },\n                \"minimumHealthCapacity\": {\n                    \"type\": \"number\",\n                    \"description\": \"A number between 0 and 1 that is multiplied with the instance count. This is the minimum number of healthy nodes that do not sacrifice overall application purpose. Marathon will make sure, during the upgrade process, that at any point of time this number of healthy instances are up.\",\n                    \"maximum\": 1,\n                    \"minimum\": 0\n                }\n            }\n        },\n        \"uris\": {\n            \"type\": \"array\",\n            \"description\": \"URIs defined here are resolved, before the application gets started. If the application has external dependencies, they should be defined here.\",\n            \"items\": {\n                \"type\": \"string\",\n                \"minLength\": 1\n            }\n        },\n        \"user\": {\n            \"type\": \"string\",\n            \"description\": \"The user to use to run the tasks on the agent.\"\n        },\n        \"version\": {\n            \"type\": \"string\",\n            \"description\": \"The version of this definition.\",\n            \"format\": \"date-time\"\n        },\n        \"versionInfo\": {\n            \"type\": \"object\",\n            \"description\": \"Detailed version information.\",\n            \"additionalProperties\": false,\n            \"properties\": {\n                \"lastScalingAt\": {\n                    \"type\": \"string\",\n                    \"description\": \"Contains the time stamp of the last change to this app which was not simply a scaling or a restarting configuration.\",\n                    \"format\": \"date-time\"\n                },\n                \"lastConfigChangeAt\": {\n                    \"type\": \"string\",\n                    \"description\": \"Contains the time stamp of the last change including changes like scaling or restarting the app. Since our versions are time based, this is currently equal to version.\",\n                    \"format\": \"date-time\"\n                }\n            }\n        }\n    },\n    \"required\": [\n        \"id\"\n    ],\n    \"type\": \"object\"\n}"
  - Group: "{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"id\": \"https://raw.githubusercontent.com/mesosphere/marathon/master/docs/docs/rest-api/public/api/v2/schema/Group.json\",\n    \"additionalProperties\": false,\n    \"definitions\": {\n        \"pathType\": {\n            \"type\": \"string\",\n            \"pattern\": \"^(\\\\/?((\\\\.{2})|([a-z0-9][a-z0-9\\\\-.]*[a-z0-9]+)|([a-z0-9]*))($|\\\\/))+$\",\n            \"minLength\": 1\n        }\n    },\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"$ref\": \"#/definitions/pathType\",\n            \"description\": \"Unique identifier for the app consisting of a series of names separated by slashes. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.\"\n        },\n        \"apps\": {\n            \"type\": \"array\",\n            \"description\": \"The list of AppDefinitions in this group. See AppDefinition.json for the schema.\",\n            \"items\": {\n                \"$ref\": \"./AppDefinition.json\"\n            }\n        },\n        \"groups\": {\n            \"type\": \"array\",\n            \"description\": \"Groups can build a tree. Each group can contain sub-groups. The sub-groups are defined here.\",\n            \"items\": {\n                \"$ref\": \"#\"\n            }\n        },\n        \"dependencies\": {\n            \"type\": \"array\",\n            \"description\": \"A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.\",\n            \"items\": {\n                \"$ref\": \"#/definitions/pathType\"\n            }\n        },\n        \"version\": {\n            \"type\": \"string\",\n            \"description\": \"The version of this definition.\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"required\": [\n        \"id\"\n    ]\n}"
